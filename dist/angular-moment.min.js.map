{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///angular-moment.min.js","webpack:///webpack/bootstrap 5b8bf269beb9162ee226","webpack:///external \"angular\"","webpack:///./src/directive_input.js","webpack:///./src/directive_momentPicker.js","webpack:///./src/directive_picker.js","webpack:///./src/filter.js","webpack:///./src/service.js","webpack:///./~/indexof/index.js","webpack:///./src/utils.js","webpack:///external \"moment\"","webpack:///./src/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_angular__","__WEBPACK_IMPORTED_MODULE_0_angular___default","__WEBPACK_IMPORTED_MODULE_1_indexof__","__WEBPACK_IMPORTED_MODULE_1_indexof___default","$moment","$timeout","stepUnits","strictView","$strictView","strictModel","$strictModel","priority","restrict","compile","tElement","tAttr","type","a","noop","scope","element","attr","ctrl","momentValue","stepUnit","stepQuantity","viewFormat","$defaultViewFormat","modelFormat","$defaultModelFormat","hasFocus","moments","min","view","model","max","setPlaceholder","format","$parseFormat","reparseOrReformatValue","hasModelValue","$isEmpty","$modelValue","hasViewValue","$viewValue","reformatModelValue","reparseViewValue","val","$setViewValue","modelValue","$apply","ngModel","setViewModelMomentsForAttr","isValid","parseValidateAndFormatDate","origin","moment","isEmpty","inputFormat","outputFormat","strict","clone","$setValidity","isBefore","isAfter","$error","$parsers","push","bind","undefined","$formatters","$eval","$watch","minWatchAction","minAttr","isArray","length","isString","maxWatchAction","maxAttr","step","match","parseInt","inputStepHandler","event","eventData","which","extend","test","preventDefault","wheelDelta","isIncrease","shiftedStepUnit","momentViewStepped","steppedViewValue","isViewEmpty","momentView","originalEvent","shiftKey","replace","add","subtract","$render","on","e","$log","weekStartDay","startOf","getTemplateDefinition","templateName","$$pickerTemplates","templateUrl","tAttrs","template","url","error","dateModel","ngShow","controller","$scope","$element","$attr","$parse","$animate","init","today","lastMonthMoments","thisMonthMoments","nextMonthMoments","monthsThisYearMoments","self","setDisplayMoment","rebuildScopeMoments","weekMoments","unshift","lastMonthMoment","displayMoment","thisMonthMoment","nextMonthMoment","endOf","thisMonth","thisYear","isSame","year","month","pickedMoment","Number","NaN","maxMoment","minMoment","visible","hidden","setVisibility","isVisible","setPickedMoment","input","lang","apply","arguments","unit","fallbackMoment","setMinMoment","setMaxMoment","setFormat","equals","minValue","maxValue","setPickerVisibility","link","getClasses","classes","isWeekend","isoWeekday","isWeekday","classObject","weekend","weekday","toLowerCase","forEach","split","className","__WEBPACK_IMPORTED_MODULE_1__utils__","$compile","defaultStyleAttr","copiedAttrs","toSpinalCase","string","w","deregisterWatch","pickerScope","pickerElem","isolateScope","pickerCtrl","showClose","pickerAttrs","picker","join","document","body","append","offset","css","left","top","bottom","$on","off","remove","date","isDefined","$momentProvider","__WEBPACK_IMPORTED_MODULE_1_moment___default","_longDateFormat","config","defaultFormat","defaultViewFormat","defaultModelFormat","bool","definePickerTemplate","isObject","$get","copy","writable","err","__WEBPACK_IMPORTED_MODULE_1_moment__","indexOf","arr","obj","getOffset","elem","isBoxModel","clientTop","clientLeft","scrollTop","scrollLeft","offsetTop","offsetRight","offsetBottom","offsetLeft","adjustedScrollTop","adjustedScrollLeft","doc","win","window","bodyElem","docElem","documentElement","boxElem","createElement","style","paddingLeft","width","appendChild","offsetWidth","removeChild","getBoundingClientRect","pageYOffset","pageXOffset","right","__WEBPACK_IMPORTED_MODULE_1__service__","__WEBPACK_IMPORTED_MODULE_2__filter__","__WEBPACK_IMPORTED_MODULE_3__directive_input__","__WEBPACK_IMPORTED_MODULE_4__directive_momentPicker__","__WEBPACK_IMPORTED_MODULE_5__directive_picker__","provider","filter","directive"],"mappings":"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","file":"angular-moment.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$moment\"] = factory(require(\"angular\"), require(\"moment\"));\n\telse\n\t\troot[\"$moment\"] = factory(root[\"angular\"], root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$moment\"] = factory(require(\"angular\"), require(\"moment\"));\n\telse\n\t\troot[\"$moment\"] = factory(root[\"angular\"], root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_indexof__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_indexof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_indexof__);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$timeout', function inputDirective ($moment, $timeout) {\n  // Maybe expose a setting for localization someday...\n  var stepUnits = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year']\n  var strictView = $moment.$strictView\n  var strictModel = $moment.$strictModel\n\n  return {\n    priority: 10,\n    restrict: 'E',\n    require: '?ngModel',\n    compile: function inputCompile (tElement, tAttr) {\n      // Support both input[type=date] and input[type=moment] so one can use type=moment if\n      // browser vendor type=date functionality is undesired (*ehem* Chrome).\n      if (tAttr.type !== 'date' && tAttr.type !== 'moment') { return __WEBPACK_IMPORTED_MODULE_0_angular___default.a.noop }\n      return function inputPostLink (scope, element, attr, ctrl) {\n        // All the functionality of this directive requires ngModelCtrl.\n        if (!ctrl) return\n\n        // A Moment of the last value passed through the directive's validator. Allows\n        // stepping function to not have to reparse ctrl.$viewValue and potentially fail\n        // if another directive's formatter has changed the view value format.\n        var momentValue\n            // Formats may be overridden if attr.(view|model)Format or attr.format is set.\n        var viewFormat = $moment.$defaultViewFormat\n        var modelFormat = $moment.$defaultModelFormat\n        var stepUnit, stepQuantity\n            // We track focus state to prevent stepping if elem is blurred.\n        var hasFocus = false\n            // Min/max must be reparsed using view/model formats to account for differences\n            // in date specificity. E.g., if min is '01-30-2000' and viewFormat is 'MM-YYYY'\n            // and the model value is '01-2000'.\n        var moments = {\n          min: {\n            attr: null,\n            view: null,\n            model: null\n          },\n          max: {\n            attr: null,\n            view: null,\n            model: null\n          }\n        }\n\n        var setPlaceholder = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.noop\n\n        // Utility Functions\n        // ///////////////////\n\n        if (element.attr('placeholder') == null) {\n          setPlaceholder = function (format) {\n            element.attr('placeholder', $moment.$parseFormat(format))\n          }\n        }\n\n        var reparseOrReformatValue = function () {\n          var hasModelValue = !ctrl.$isEmpty(ctrl.$modelValue)\n          var hasViewValue = !ctrl.$isEmpty(ctrl.$viewValue)\n\n          if (hasModelValue) { reformatModelValue() } else if (hasViewValue) { reparseViewValue() }\n        }\n\n        var reparseViewValue = function () {\n          if (!ctrl.$isEmpty(ctrl.$viewValue)) {\n            var val = ctrl.$viewValue\n            ctrl.$setViewValue(val + ' ')\n            ctrl.$setViewValue(val)\n          }\n        }\n        var reformatModelValue = function () {\n          // Is there a better way to resend the model value through the formatter pipeline?\n          var modelValue = ctrl.$modelValue\n          if (!ctrl.$isEmpty(modelValue)) {\n            $timeout(function () {\n              scope.$apply(function () { scope[attr.ngModel] = modelValue + ' ' })\n              scope.$apply(function () { scope[attr.ngModel] = modelValue })\n            }, 0, false)\n          }\n        }\n\n        var setViewModelMomentsForAttr = function (attr) {\n          // attr is either 'min' or 'max'\n          if (moments[attr].attr && moments[attr].attr.isValid()) {\n            moments[attr].view = $moment(moments[attr].attr.format(viewFormat), viewFormat)\n            moments[attr].model = $moment(moments[attr].attr.format(modelFormat), modelFormat)\n          } else { moments[attr].attr = moments[attr].view = moments[attr].model = null }\n        }\n\n        // Date Validation and Formatting\n        // ////////////////////////////////\n\n        var parseValidateAndFormatDate = function parseValidateAndFormatDate (origin, value) {\n          var moment, isValid, isEmpty, inputFormat, outputFormat, strict\n\n          if (origin === 'view') {\n            inputFormat = viewFormat\n            outputFormat = modelFormat\n            strict = strictView\n          } else {\n            inputFormat = modelFormat\n            outputFormat = viewFormat\n            strict = strictModel\n          }\n\n          moment = $moment(value, inputFormat, strict)\n          isValid = moment.isValid()\n          isEmpty = ctrl.$isEmpty(value)\n          momentValue = isEmpty ? $moment(null) : moment.clone()\n\n          // Date validation\n          if (!isEmpty && !isValid) {\n            ctrl.$setValidity('date', false)\n            if (attr.min) ctrl.$setValidity('min', true)\n            if (attr.max) ctrl.$setValidity('max', true)\n            return undefined\n          } else { ctrl.$setValidity('date', true) }\n\n          // Min validation\n          if (attr.min) {\n            if (!isEmpty && isValid && moments.min.attr && moment.isBefore(moments.min[origin])) { ctrl.$setValidity('min', false) } else { ctrl.$setValidity('min', true) }\n          }\n\n          // Max validation\n          if (attr.max) {\n            if (!isEmpty && isValid && moments.max.attr && moment.isAfter(moments.max[origin])) { ctrl.$setValidity('max', false) } else { ctrl.$setValidity('max', true) }\n          }\n\n          // Output and formatting\n          if (ctrl.$error.min || ctrl.$error.max) { return undefined } else { return isEmpty ? value : moment.format(outputFormat) }\n        }\n\n        ctrl.$parsers.push(__WEBPACK_IMPORTED_MODULE_0_angular___default.a.bind(undefined, parseValidateAndFormatDate, 'view'))\n        ctrl.$formatters.push(__WEBPACK_IMPORTED_MODULE_0_angular___default.a.bind(undefined, parseValidateAndFormatDate, 'model'))\n\n        // Process format, viewFormat, modelFormat attrs\n        // ///////////////////////////////////////////////\n\n        if (attr.format && (!attr.viewFormat || !attr.modelFormat)) {\n          viewFormat = scope.$eval(attr.format) || viewFormat\n          modelFormat = scope.$eval(attr.format) || modelFormat\n\n          scope.$watch(attr.format, function formatWatchAction (value) {\n            viewFormat = value\n            modelFormat = value\n            setPlaceholder(value)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        if (attr.viewFormat) {\n          viewFormat = scope.$eval(attr.viewFormat) || viewFormat\n\n          scope.$watch(attr.viewFormat, function viewFormatWatchAction (format) {\n            format = format || $moment.$defaultViewFormat\n            if (format === viewFormat) return\n            viewFormat = format\n            setPlaceholder(format)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reformatModelValue()\n          })\n        }\n\n        if (attr.modelFormat) {\n          modelFormat = scope.$eval(attr.modelFormat) || modelFormat\n\n          scope.$watch(attr.modelFormat, function modelFormatWatchAction (format) {\n            format = format || $moment.$defaultModelFormat\n            if (format === modelFormat) return\n            modelFormat = format\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        setPlaceholder(viewFormat)\n\n        // Min/Max Validation\n        // ////////////////////\n\n        var minWatchAction = function minWatchAction (minAttr) {\n          var moment\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(minAttr) && minAttr.length === 2) { moment = $moment(minAttr[0], minAttr[1]) } else if (minAttr && __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(minAttr)) {\n            if (minAttr === 'today') { moment = $moment() } else { moment = $moment(minAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n          // Has the min changed?\n          if (!moment ^ !moments.min.attr || (moment && moments.min.attr && moment.format('X') !== moments.min.attr.format('X'))) {\n            moments.min.attr = moment\n            setViewModelMomentsForAttr('min')\n            reparseOrReformatValue()\n          }\n        }\n\n        minWatchAction(scope.$eval(attr.min))\n        scope.$watch(function () {\n          return scope.$eval(attr.min)\n        }, minWatchAction, true)\n\n        var maxWatchAction = function maxWatchAction (maxAttr) {\n          var moment\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(maxAttr) && maxAttr.length === 2) { moment = $moment(maxAttr[0], maxAttr[1]) } else if (maxAttr && __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(maxAttr)) {\n            if (maxAttr === 'today') { moment = $moment() } else { moment = $moment(maxAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n\n          if (!moment ^ !moments.max.attr || (moment && moments.max.attr && moment.format('X') !== moments.max.attr.format('X'))) {\n            moments.max.attr = moment\n            setViewModelMomentsForAttr('max')\n            reparseOrReformatValue()\n          }\n        }\n\n        maxWatchAction(scope.$eval(attr.max))\n        scope.$watch(function () {\n          return scope.$eval(attr.max)\n        }, maxWatchAction, true)\n\n        // Stepping\n        // //////////\n\n        // TODO: Allow this to be config'ed\n        stepUnit = 'day'\n        stepQuantity = 1\n\n        if (attr.step) {\n          scope.$watch(attr.step, function stepWatchAction (step) {\n            if (!step || !__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(step)) { return }\n\n            var match = step.match(/(\\d+)\\s(\\w+)/)\n            if (match) {\n              stepUnit = match[2]\n              stepQuantity = parseInt(match[1], 10)\n            } else {\n              stepUnit = 'day'\n              stepQuantity = 1\n            }\n          })\n        }\n\n        var inputStepHandler = function (event, eventData) {\n          // Allow for passing custom event object in tests (so Kosher)\n          if (eventData && (eventData.type || eventData.which)) {\n            __WEBPACK_IMPORTED_MODULE_0_angular___default.a.extend(event, eventData)\n            hasFocus = true\n          }\n\n          if (element.attr('readonly')) { return }\n\n          //                               Up|Dn\n          if (!hasFocus || (event.type === 'keydown' && !/38|40/.test(event.which))) return\n          event.preventDefault()\n\n          var isViewEmpty = ctrl.$isEmpty(ctrl.$viewValue)\n          var momentView = isViewEmpty ? $moment() : $moment(momentValue.format(viewFormat), viewFormat, true)\n          var wheelDelta, isIncrease, shiftedStepUnit, momentViewStepped, steppedViewValue\n\n          if (!momentView.isValid()) { return }\n\n          if (event.type === 'keydown') { isIncrease = /38/.test(event.which) } else {\n            wheelDelta = event.originalEvent ? event.originalEvent.wheelDelta : event.wheelDelta\n            isIncrease = wheelDelta / 120 > 0\n          }\n\n          if (event.shiftKey) {\n            shiftedStepUnit = stepUnits[(__WEBPACK_IMPORTED_MODULE_1_indexof___default()(stepUnits, stepUnit.replace(/s$/, '')) + 1)] || stepUnit\n          } else shiftedStepUnit = stepUnit\n\n          if (isViewEmpty && moments.min.attr) {\n            // Always step an empty value to the min if specified\n            momentViewStepped = moments.min.view.clone()\n          } else if (isIncrease) {\n            if (isViewEmpty && !moments.min.attr) {\n              // Then use today's date clamped to max\n              momentViewStepped = momentView.max(moments.max.attr ? moments.max.view : undefined)\n            } else if (moments.min.attr && momentView.isBefore(moments.min.view)) {\n              momentViewStepped = moments.min.view.clone()\n            } else if (moments.max.attr && !momentView.isAfter(moments.max.view)) {\n              // Then step value up, clamp to max\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity).max(moments.max.view)\n            } else if (!moments.max.attr) {\n              // If there's no max, increase; otherwise leave it exceeding max--we'll only bring it\n              // back in bounds of the max when user decreases value.\n              // This mimic's browser vendor behavior with min/max stepping for input[type=number]\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity)\n            }\n          } else {\n            // The opposite for decrease\n            if (isViewEmpty && !moments.max.attr) {\n              momentViewStepped = momentView.min(moments.min.attr ? moments.min.view : undefined)\n            } else if (moments.max.attr && momentView.isAfter(moments.max.view)) {\n              momentViewStepped = moments.max.view.clone()\n            } else if (moments.min.attr && !momentView.isBefore(moments.min.view)) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity).min(moments.min.view)\n            } else if (!moments.min.attr) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity)\n            }\n          }\n\n          steppedViewValue = (momentViewStepped || momentView).format(viewFormat)\n\n          scope.$apply(function () {\n            ctrl.$setViewValue(steppedViewValue)\n            ctrl.$render()\n          })\n        }\n\n        element.on('mousewheel keydown', inputStepHandler)\n\n        element.on('focus', function (e) { hasFocus = true })\n        element.on('blur', function (e) { hasFocus = false })\n      }\n    }\n  }\n}];\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$log', function inputDirective ($moment, $log) {\n  var weekStartDay = $moment().startOf('week').format('d')\n  // var weekEndDay = $moment().endOf('week').format('d')\n  var getTemplateDefinition = function (templateName) {\n    return $moment.$$pickerTemplates[templateName || 'default']\n  }\n\n  return {\n    restrict: 'A',\n    templateUrl: function (tElement, tAttrs) {\n      var template = getTemplateDefinition(tAttrs.template)\n      if (template) { return template.url }\n      // Ya dun' goofed.\n      $log.error('Error: [momentDatepicker] Picker template \\'' + tAttrs.template + '\\' is undefined. Templates must be defined with \\'$momentProvider.definePickerTemplate\\'.')\n    },\n    scope: {\n      dateModel: '=momentPicker',\n      format: '=?',\n      modelFormat: '=?',\n      min: '=?',\n      max: '=?',\n      ngShow: '=?'\n    },\n    controller: ['$scope', '$element', '$attrs', '$parse', '$animate', '$moment',\n      function ($scope, $element, $attr, $parse, $animate, $moment) {\n        var self = this\n\n        self.template = getTemplateDefinition($attr.template)\n        self.format = $moment.$defaultModelFormat\n\n        self.pickedMoment = Number.NaN\n        self.maxMoment = Number.NaN\n        self.minMoment = Number.NaN\n\n        self.visible = true\n        self.hidden = false\n\n        function init () {\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          self.setDisplayMoment($moment())\n          rebuildScopeMoments()\n\n          $scope.weekMoments = []\n          var i = 7\n          while (i--) { $scope.weekMoments.unshift($moment().startOf('week').add(i, 'day')) }\n        }\n\n        // Ctrl Methods\n        // //////////////\n\n        self.setVisibility = function (isVisible) {\n          self.hidden = !isVisible\n          self.visible = !!isVisible\n          $animate[!isVisible ? 'addClass' : 'removeClass']($element, 'ng-hide')\n        }\n\n        self.setPickedMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          if (!isValid) {\n            self.pickedMoment = null\n            $scope.pickedMoment = null\n            return\n          }\n\n          if (self.minMoment && moment.isBefore(self.minMoment, self.template.unit)) { return }\n          if (self.maxMoment && moment.isAfter(self.maxMoment, self.template.unit)) { return }\n\n          // Clamp it to the min/max to keep it valid\n          if (self.minMoment) { moment = moment.min(self.minMoment) }\n          if (self.maxMoment) { moment = moment.max(self.maxMoment) }\n\n          if (moment.isSame(self.pickedMoment)) { return }\n\n          self.pickedMoment = moment.clone()\n          $scope.pickedMoment = moment.clone()\n          $scope.dateModel = moment.format(self.format)\n\n          self.setDisplayMoment(moment)\n        }\n\n        self.setDisplayMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n          var fallbackMoment = self.pickedMoment ? self.pickedMoment : $moment()\n\n          self.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n          $scope.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n\n          rebuildScopeMoments()\n        }\n\n        self.setMinMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.minMoment = isValid ? moment.clone() : null\n        }\n\n        self.setMaxMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.maxMoment = isValid ? moment.clone() : null\n        }\n\n        self.setFormat = function (format) {\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.equals(self.format, format)) { return }\n\n          self.format = format || $moment.$defaultModelFormat\n          self.setPickedMoment($scope.dateModel, self.format, $moment.$strictModel)\n        }\n\n        // Watchers\n        // /////////\n\n        $scope.$watch('dateModel', function (modelValue) {\n          self.setPickedMoment(modelValue, self.format, $moment.$strictModel)\n        })\n\n        // Format or modelFormat\n        if ($attr.format && !$attr.modelFormat) {\n          self.format = $scope.format || $moment.$defaultModelFormat\n          $scope.$watch('format', self.setFormat)\n        } else if ($attr.modelFormat) {\n          self.format = $scope.modelFormat || $moment.$defaultModelFormat\n          $scope.$watch('modelFormat', self.setFormat)\n        }\n\n        // Min, Max\n        if ($attr.min) {\n          $scope.$watch('min', function (minValue) {\n            var isArray = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(minValue)\n            self.setMinMoment.apply(null, isArray ? minValue : [minValue])\n          }, true)\n        }\n\n        if ($attr.max) {\n          $scope.$watch('max', function (maxValue) {\n            var isArray = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(maxValue)\n            self.setMaxMoment.apply(null, isArray ? maxValue : [maxValue])\n          }, true)\n        }\n\n        // Add ctrl methods to the scope that are\n        // suitable for use in the picker template.\n        // /////////////////////////////////////////\n\n        $scope.setPickerVisibility = self.setVisibility\n        $scope.setDisplayMoment = self.setDisplayMoment\n        $scope.setPickedMoment = self.setPickedMoment\n\n        // Private methods\n\n        function rebuildScopeMoments () {\n          var lastMonthMoment = self.displayMoment.clone().startOf('month')\n          var thisMonthMoment = lastMonthMoment.clone()\n          var nextMonthMoment = self.displayMoment.clone().endOf('month')\n          var thisMonth = self.displayMoment.format('M')\n          var thisYear = self.displayMoment.format('YYYY')\n\n          if ($scope.thisMonthMoments.length && thisMonthMoment.isSame($scope.thisMonthMoments[0])) { return }\n\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          while (lastMonthMoment.format('d') !== weekStartDay) { $scope.lastMonthMoments.unshift(lastMonthMoment.subtract(1, 'day').clone()) }\n\n          while (thisMonthMoment.format('M') === thisMonth) {\n            $scope.thisMonthMoments.push(thisMonthMoment.clone())\n            thisMonthMoment.add(1, 'day')\n          }\n\n          while ($scope.lastMonthMoments.length + $scope.thisMonthMoments.length + $scope.nextMonthMoments.length < 42) { $scope.nextMonthMoments.push(nextMonthMoment.add(1, 'day').clone()) }\n\n          while ($scope.monthsThisYearMoments.length < 12) {\n            $scope.monthsThisYearMoments.push($moment({ year: thisYear, month: $scope.monthsThisYearMoments.length }))\n          }\n        }\n\n        init()\n      }\n    ],\n    require: 'momentPicker',\n    link: function (scope, element, attr, ctrl) {\n      // View helpers\n      // //////////////\n\n      scope.getClasses = function (moment, classes) {\n        var isWeekend = /6|7/.test(moment.isoWeekday())\n        var isWeekday = !isWeekend\n        var classObject = {\n          weekend: isWeekend,\n          weekday: isWeekday\n        }\n\n        // Convenience classes: jan fri\n        classObject[ moment.format('MMM ddd').toLowerCase() ] = true\n\n        if (!classes) { return classObject }\n\n        // Iterate over requested class names\n        __WEBPACK_IMPORTED_MODULE_0_angular___default.a.forEach(classes.split(' '), function (className) {\n          var name = className.split('-')[0]\n          var unit = className.split('-')[1] || ctrl.template.unit\n\n          if (scope.pickedMoment && name === 'picked') {\n            classObject[className] = moment.isSame(scope.pickedMoment, ctrl.template.unit)\n          } else if (name === 'current') {\n            classObject[className + ' current'] = moment.isSame(scope.today, unit)\n          } else if (name === 'invalid' && (ctrl.minMoment || ctrl.maxMoment)) {\n            if (ctrl.minMoment && moment.isBefore(ctrl.minMoment, unit)) {\n              classObject[className + ' invalid'] = true\n            } else if (ctrl.maxMoment && moment.isAfter(ctrl.maxMoment, unit)) {\n              classObject[className + ' invalid'] = true\n            }\n          }\n        })\n\n        return classObject\n      }\n    }\n  }\n}];\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(7);\n// Picker extends moment input directive with positioned momentPicker\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$compile', function inputDirective ($moment, $compile) {\n  var defaultStyleAttr = 'style=\"position:absolute\" class=\"input-picker\"'\n  var copiedAttrs = 'format modelFormat min max'.split(' ')\n\n  var toSpinalCase = function (string) {\n    return string.replace(/[a-z][A-Z]/g, function (w) { return w[0] + '-' + w[1] }).toLowerCase()\n  }\n\n  return {\n    restrict: 'A',\n    require: ['?ngModel'],\n    link: function (scope, element, attr, ctrl) {\n      if (!ctrl || attr.type !== 'moment') { return }\n\n      var pickerAttrs = [ defaultStyleAttr ]\n      var pickerElem, pickerScope, pickerCtrl, deregisterWatch\n\n      function init () {\n        deregisterWatch()\n        pickerScope = pickerElem.isolateScope()\n        pickerCtrl = pickerElem.controller('momentPicker')\n        pickerCtrl.setVisibility(false)\n        pickerScope.showClose = true\n      }\n\n      // Copy relevent attrs from input to picker\n      if (attr.picker) { pickerAttrs.push('template=' + attr.picker) }\n\n      __WEBPACK_IMPORTED_MODULE_0_angular___default.a.forEach(copiedAttrs, function (name) {\n        if (attr[name]) { pickerAttrs.push(toSpinalCase(name) + '=\"' + attr[name] + '\"') }\n      })\n\n      // Compile/inject/bind events to picker\n      pickerElem = $compile('<div moment-picker=\"' + attr.ngModel + '\" ' + pickerAttrs.join(' ') + '></div>')(scope)\n\n      // Watch for controller instantiation\n      deregisterWatch = scope.$watch(function () {\n        if (pickerElem.controller('momentPicker')) { init() }\n      })\n\n      // DOM manipulation and event watching\n      __WEBPACK_IMPORTED_MODULE_0_angular___default.a.element(document.body).append(pickerElem)\n\n      pickerElem.on('mousedown', function (event) {\n        event.preventDefault()\n      })\n\n      // Input event binding\n      element.on('focus click', function (event) {\n        var offset = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getOffset */])(element[0])\n\n        pickerElem.css({\n          left: offset.left + 'px',\n          top: offset.bottom + 'px'\n        })\n\n        pickerCtrl.setVisibility(true)\n      })\n\n      element.on('blur keydown', function (event) {\n        if (event.type === 'keydown' && event.which !== 27) { return }\n        pickerCtrl.setVisibility(false)\n      })\n\n      // Destruction cleanup\n      scope.$on('$destroy', function () {\n        pickerElem.off().remove()\n      })\n    }\n  }\n}];\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', function ($moment) {\n  // Format: String or Array\n  // String: Moment output format (defaults to defaultViewFormat)\n  // Array: Moment input format, moment output format, [strict]\n  return function momentFormatFilter (date, format) {\n    var moment, strict, inputFormat\n    var outputFormat = $moment.$defaultViewFormat\n\n    if (!__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(date)) { return date }\n\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { outputFormat = format } else if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(format)) {\n      inputFormat = format[0]\n      outputFormat = format[1] || outputFormat\n      strict = format[2]\n    }\n\n    moment = $moment(date, inputFormat, strict)\n\n    if (moment.isValid()) { return moment.format(outputFormat) }\n\n    // Try parsing it with the defaultModelFormat if inputFormat wasn't specified\n    if (!__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(inputFormat)) {\n      moment = $moment(date, $moment.$defaultModelFormat, $moment.strictModel)\n      if (moment.isValid()) { return moment.format(outputFormat) }\n    }\n\n    return date\n  }\n}];\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = $momentProvider;\n\n\n\nfunction $momentProvider () {\n  // Strict parsing has trouble in Moment.js v2.32.5 with short tokens\n  // E.g. 1-31-2000, M-D-YYYY is invalid.\n  var config = {\n    $$pickerTemplates: {},\n    $strictView: true,\n    $strictModel: true,\n    $defaultViewFormat: 'L',\n    $defaultModelFormat: __WEBPACK_IMPORTED_MODULE_1_moment___default.a.defaultFormat,\n    $parseFormat: $parseFormat\n  }\n\n  // For parsing locale-dependent date formats (L, LL, etc.)\n  function $parseFormat (format) {\n    format = format || ''\n    if (format.match(/l/i)) { return __WEBPACK_IMPORTED_MODULE_1_moment___default()().lang()._longDateFormat[format] || format }\n    return format\n  }\n\n  this.defaultViewFormat = function (format) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { config.$defaultViewFormat = format }\n    return this\n  }\n\n  this.defaultModelFormat = function (format) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { config.$defaultModelFormat = format }\n    return this\n  }\n\n  this.strictView = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictView = bool }\n    return this\n  }\n\n  this.strictModel = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictModel = bool }\n    return this\n  }\n\n  this.definePickerTemplate = function (template) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isObject(template) && template.name && template.url) {\n      config.$$pickerTemplates[template.name] = {\n        url: template.url,\n        unit: template.unit || 'days'\n      }\n    }\n    return this\n  }\n\n  this.$get = function () {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(__WEBPACK_IMPORTED_MODULE_1_moment___default.a.$strictView)) { return __WEBPACK_IMPORTED_MODULE_1_moment___default.a }\n    try {\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$strictView', {\n        value: config.$strictView\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$strictModel', {\n        value: config.$strictModel\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$defaultViewFormat', {\n        value: config.$defaultViewFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$defaultModelFormat', {\n        value: config.$defaultModelFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$parseFormat', {\n        value: config.$parseFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$$pickerTemplates', {\n        value: __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(config.$$pickerTemplates),\n        writable: true\n      })\n    } catch (err) { __WEBPACK_IMPORTED_MODULE_0_angular___default.a.extend(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, config) }\n    return __WEBPACK_IMPORTED_MODULE_1_moment___default.a\n  }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getOffset; });\n\n\nfunction getOffset (elem) {\n  // Based on http://stackoverflow.com/a/8111175\n  if (!elem) { return }\n\n  var doc = document\n  var win = window\n  var bodyElem = doc.body\n  var docElem = doc.documentElement\n  var boxElem = doc.createElement('div')\n  var isBoxModel,\n    clientTop, clientLeft,\n    scrollTop, scrollLeft,\n    offsetTop, offsetRight, offsetBottom, offsetLeft,\n    adjustedScrollTop,\n    adjustedScrollLeft\n\n  boxElem.style.paddingLeft =\n  boxElem.style.width = '1px'\n\n  bodyElem.appendChild(boxElem)\n  isBoxModel = boxElem.offsetWidth === 2\n  bodyElem.removeChild(boxElem)\n  boxElem = elem.getBoundingClientRect()\n\n  clientTop = docElem.clientTop || bodyElem.clientTop || 0\n  clientLeft = docElem.clientLeft || bodyElem.clientLeft || 0\n  scrollTop = win.pageYOffset || isBoxModel && docElem.scrollTop || bodyElem.scrollTop\n  scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || bodyElem.scrollLeft\n\n  adjustedScrollTop = scrollTop - clientTop\n  adjustedScrollLeft = scrollLeft - clientLeft\n\n  offsetTop = boxElem.top + adjustedScrollTop\n  offsetLeft = boxElem.left + adjustedScrollLeft\n  offsetBottom = boxElem.bottom + adjustedScrollTop\n  offsetRight = boxElem.right + adjustedScrollLeft\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetBottom,\n    right: offsetRight\n  }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directive_input__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directive_momentPicker__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directive_picker__ = __webpack_require__(3);\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = __WEBPACK_IMPORTED_MODULE_0_angular___default.a\n  .module('$moment', [])\n  .provider('$moment', __WEBPACK_IMPORTED_MODULE_1__service__[\"a\" /* default */])\n  .filter('momentFormat', __WEBPACK_IMPORTED_MODULE_2__filter__[\"a\" /* default */])\n  .directive('input', __WEBPACK_IMPORTED_MODULE_3__directive_input__[\"a\" /* default */])\n  .directive('picker', __WEBPACK_IMPORTED_MODULE_5__directive_picker__[\"a\" /* default */])\n  .directive('momentPicker', __WEBPACK_IMPORTED_MODULE_4__directive_momentPicker__[\"a\" /* default */])\n  .name;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// angular-moment.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b8bf269beb9162ee226","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 0\n// module chunks = 0","import angular from 'angular'\nimport indexOf from 'indexof'\n\nexport default ['$moment', '$timeout', function inputDirective ($moment, $timeout) {\n  // Maybe expose a setting for localization someday...\n  var stepUnits = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year']\n  var strictView = $moment.$strictView\n  var strictModel = $moment.$strictModel\n\n  return {\n    priority: 10,\n    restrict: 'E',\n    require: '?ngModel',\n    compile: function inputCompile (tElement, tAttr) {\n      // Support both input[type=date] and input[type=moment] so one can use type=moment if\n      // browser vendor type=date functionality is undesired (*ehem* Chrome).\n      if (tAttr.type !== 'date' && tAttr.type !== 'moment') { return angular.noop }\n      return function inputPostLink (scope, element, attr, ctrl) {\n        // All the functionality of this directive requires ngModelCtrl.\n        if (!ctrl) return\n\n        // A Moment of the last value passed through the directive's validator. Allows\n        // stepping function to not have to reparse ctrl.$viewValue and potentially fail\n        // if another directive's formatter has changed the view value format.\n        var momentValue\n            // Formats may be overridden if attr.(view|model)Format or attr.format is set.\n        var viewFormat = $moment.$defaultViewFormat\n        var modelFormat = $moment.$defaultModelFormat\n        var stepUnit, stepQuantity\n            // We track focus state to prevent stepping if elem is blurred.\n        var hasFocus = false\n            // Min/max must be reparsed using view/model formats to account for differences\n            // in date specificity. E.g., if min is '01-30-2000' and viewFormat is 'MM-YYYY'\n            // and the model value is '01-2000'.\n        var moments = {\n          min: {\n            attr: null,\n            view: null,\n            model: null\n          },\n          max: {\n            attr: null,\n            view: null,\n            model: null\n          }\n        }\n\n        var setPlaceholder = angular.noop\n\n        // Utility Functions\n        // ///////////////////\n\n        if (element.attr('placeholder') == null) {\n          setPlaceholder = function (format) {\n            element.attr('placeholder', $moment.$parseFormat(format))\n          }\n        }\n\n        var reparseOrReformatValue = function () {\n          var hasModelValue = !ctrl.$isEmpty(ctrl.$modelValue)\n          var hasViewValue = !ctrl.$isEmpty(ctrl.$viewValue)\n\n          if (hasModelValue) { reformatModelValue() } else if (hasViewValue) { reparseViewValue() }\n        }\n\n        var reparseViewValue = function () {\n          if (!ctrl.$isEmpty(ctrl.$viewValue)) {\n            var val = ctrl.$viewValue\n            ctrl.$setViewValue(val + ' ')\n            ctrl.$setViewValue(val)\n          }\n        }\n        var reformatModelValue = function () {\n          // Is there a better way to resend the model value through the formatter pipeline?\n          var modelValue = ctrl.$modelValue\n          if (!ctrl.$isEmpty(modelValue)) {\n            $timeout(function () {\n              scope.$apply(function () { scope[attr.ngModel] = modelValue + ' ' })\n              scope.$apply(function () { scope[attr.ngModel] = modelValue })\n            }, 0, false)\n          }\n        }\n\n        var setViewModelMomentsForAttr = function (attr) {\n          // attr is either 'min' or 'max'\n          if (moments[attr].attr && moments[attr].attr.isValid()) {\n            moments[attr].view = $moment(moments[attr].attr.format(viewFormat), viewFormat)\n            moments[attr].model = $moment(moments[attr].attr.format(modelFormat), modelFormat)\n          } else { moments[attr].attr = moments[attr].view = moments[attr].model = null }\n        }\n\n        // Date Validation and Formatting\n        // ////////////////////////////////\n\n        var parseValidateAndFormatDate = function parseValidateAndFormatDate (origin, value) {\n          var moment, isValid, isEmpty, inputFormat, outputFormat, strict\n\n          if (origin === 'view') {\n            inputFormat = viewFormat\n            outputFormat = modelFormat\n            strict = strictView\n          } else {\n            inputFormat = modelFormat\n            outputFormat = viewFormat\n            strict = strictModel\n          }\n\n          moment = $moment(value, inputFormat, strict)\n          isValid = moment.isValid()\n          isEmpty = ctrl.$isEmpty(value)\n          momentValue = isEmpty ? $moment(null) : moment.clone()\n\n          // Date validation\n          if (!isEmpty && !isValid) {\n            ctrl.$setValidity('date', false)\n            if (attr.min) ctrl.$setValidity('min', true)\n            if (attr.max) ctrl.$setValidity('max', true)\n            return undefined\n          } else { ctrl.$setValidity('date', true) }\n\n          // Min validation\n          if (attr.min) {\n            if (!isEmpty && isValid && moments.min.attr && moment.isBefore(moments.min[origin])) { ctrl.$setValidity('min', false) } else { ctrl.$setValidity('min', true) }\n          }\n\n          // Max validation\n          if (attr.max) {\n            if (!isEmpty && isValid && moments.max.attr && moment.isAfter(moments.max[origin])) { ctrl.$setValidity('max', false) } else { ctrl.$setValidity('max', true) }\n          }\n\n          // Output and formatting\n          if (ctrl.$error.min || ctrl.$error.max) { return undefined } else { return isEmpty ? value : moment.format(outputFormat) }\n        }\n\n        ctrl.$parsers.push(angular.bind(undefined, parseValidateAndFormatDate, 'view'))\n        ctrl.$formatters.push(angular.bind(undefined, parseValidateAndFormatDate, 'model'))\n\n        // Process format, viewFormat, modelFormat attrs\n        // ///////////////////////////////////////////////\n\n        if (attr.format && (!attr.viewFormat || !attr.modelFormat)) {\n          viewFormat = scope.$eval(attr.format) || viewFormat\n          modelFormat = scope.$eval(attr.format) || modelFormat\n\n          scope.$watch(attr.format, function formatWatchAction (value) {\n            viewFormat = value\n            modelFormat = value\n            setPlaceholder(value)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        if (attr.viewFormat) {\n          viewFormat = scope.$eval(attr.viewFormat) || viewFormat\n\n          scope.$watch(attr.viewFormat, function viewFormatWatchAction (format) {\n            format = format || $moment.$defaultViewFormat\n            if (format === viewFormat) return\n            viewFormat = format\n            setPlaceholder(format)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reformatModelValue()\n          })\n        }\n\n        if (attr.modelFormat) {\n          modelFormat = scope.$eval(attr.modelFormat) || modelFormat\n\n          scope.$watch(attr.modelFormat, function modelFormatWatchAction (format) {\n            format = format || $moment.$defaultModelFormat\n            if (format === modelFormat) return\n            modelFormat = format\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        setPlaceholder(viewFormat)\n\n        // Min/Max Validation\n        // ////////////////////\n\n        var minWatchAction = function minWatchAction (minAttr) {\n          var moment\n          if (angular.isArray(minAttr) && minAttr.length === 2) { moment = $moment(minAttr[0], minAttr[1]) } else if (minAttr && angular.isString(minAttr)) {\n            if (minAttr === 'today') { moment = $moment() } else { moment = $moment(minAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n          // Has the min changed?\n          if (!moment ^ !moments.min.attr || (moment && moments.min.attr && moment.format('X') !== moments.min.attr.format('X'))) {\n            moments.min.attr = moment\n            setViewModelMomentsForAttr('min')\n            reparseOrReformatValue()\n          }\n        }\n\n        minWatchAction(scope.$eval(attr.min))\n        scope.$watch(function () {\n          return scope.$eval(attr.min)\n        }, minWatchAction, true)\n\n        var maxWatchAction = function maxWatchAction (maxAttr) {\n          var moment\n          if (angular.isArray(maxAttr) && maxAttr.length === 2) { moment = $moment(maxAttr[0], maxAttr[1]) } else if (maxAttr && angular.isString(maxAttr)) {\n            if (maxAttr === 'today') { moment = $moment() } else { moment = $moment(maxAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n\n          if (!moment ^ !moments.max.attr || (moment && moments.max.attr && moment.format('X') !== moments.max.attr.format('X'))) {\n            moments.max.attr = moment\n            setViewModelMomentsForAttr('max')\n            reparseOrReformatValue()\n          }\n        }\n\n        maxWatchAction(scope.$eval(attr.max))\n        scope.$watch(function () {\n          return scope.$eval(attr.max)\n        }, maxWatchAction, true)\n\n        // Stepping\n        // //////////\n\n        // TODO: Allow this to be config'ed\n        stepUnit = 'day'\n        stepQuantity = 1\n\n        if (attr.step) {\n          scope.$watch(attr.step, function stepWatchAction (step) {\n            if (!step || !angular.isString(step)) { return }\n\n            var match = step.match(/(\\d+)\\s(\\w+)/)\n            if (match) {\n              stepUnit = match[2]\n              stepQuantity = parseInt(match[1], 10)\n            } else {\n              stepUnit = 'day'\n              stepQuantity = 1\n            }\n          })\n        }\n\n        var inputStepHandler = function (event, eventData) {\n          // Allow for passing custom event object in tests (so Kosher)\n          if (eventData && (eventData.type || eventData.which)) {\n            angular.extend(event, eventData)\n            hasFocus = true\n          }\n\n          if (element.attr('readonly')) { return }\n\n          //                               Up|Dn\n          if (!hasFocus || (event.type === 'keydown' && !/38|40/.test(event.which))) return\n          event.preventDefault()\n\n          var isViewEmpty = ctrl.$isEmpty(ctrl.$viewValue)\n          var momentView = isViewEmpty ? $moment() : $moment(momentValue.format(viewFormat), viewFormat, true)\n          var wheelDelta, isIncrease, shiftedStepUnit, momentViewStepped, steppedViewValue\n\n          if (!momentView.isValid()) { return }\n\n          if (event.type === 'keydown') { isIncrease = /38/.test(event.which) } else {\n            wheelDelta = event.originalEvent ? event.originalEvent.wheelDelta : event.wheelDelta\n            isIncrease = wheelDelta / 120 > 0\n          }\n\n          if (event.shiftKey) {\n            shiftedStepUnit = stepUnits[(indexOf(stepUnits, stepUnit.replace(/s$/, '')) + 1)] || stepUnit\n          } else shiftedStepUnit = stepUnit\n\n          if (isViewEmpty && moments.min.attr) {\n            // Always step an empty value to the min if specified\n            momentViewStepped = moments.min.view.clone()\n          } else if (isIncrease) {\n            if (isViewEmpty && !moments.min.attr) {\n              // Then use today's date clamped to max\n              momentViewStepped = momentView.max(moments.max.attr ? moments.max.view : undefined)\n            } else if (moments.min.attr && momentView.isBefore(moments.min.view)) {\n              momentViewStepped = moments.min.view.clone()\n            } else if (moments.max.attr && !momentView.isAfter(moments.max.view)) {\n              // Then step value up, clamp to max\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity).max(moments.max.view)\n            } else if (!moments.max.attr) {\n              // If there's no max, increase; otherwise leave it exceeding max--we'll only bring it\n              // back in bounds of the max when user decreases value.\n              // This mimic's browser vendor behavior with min/max stepping for input[type=number]\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity)\n            }\n          } else {\n            // The opposite for decrease\n            if (isViewEmpty && !moments.max.attr) {\n              momentViewStepped = momentView.min(moments.min.attr ? moments.min.view : undefined)\n            } else if (moments.max.attr && momentView.isAfter(moments.max.view)) {\n              momentViewStepped = moments.max.view.clone()\n            } else if (moments.min.attr && !momentView.isBefore(moments.min.view)) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity).min(moments.min.view)\n            } else if (!moments.min.attr) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity)\n            }\n          }\n\n          steppedViewValue = (momentViewStepped || momentView).format(viewFormat)\n\n          scope.$apply(function () {\n            ctrl.$setViewValue(steppedViewValue)\n            ctrl.$render()\n          })\n        }\n\n        element.on('mousewheel keydown', inputStepHandler)\n\n        element.on('focus', function (e) { hasFocus = true })\n        element.on('blur', function (e) { hasFocus = false })\n      }\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_input.js\n// module id = 1\n// module chunks = 0","import angular from 'angular'\n\nexport default ['$moment', '$log', function inputDirective ($moment, $log) {\n  var weekStartDay = $moment().startOf('week').format('d')\n  // var weekEndDay = $moment().endOf('week').format('d')\n  var getTemplateDefinition = function (templateName) {\n    return $moment.$$pickerTemplates[templateName || 'default']\n  }\n\n  return {\n    restrict: 'A',\n    templateUrl: function (tElement, tAttrs) {\n      var template = getTemplateDefinition(tAttrs.template)\n      if (template) { return template.url }\n      // Ya dun' goofed.\n      $log.error('Error: [momentDatepicker] Picker template \\'' + tAttrs.template + '\\' is undefined. Templates must be defined with \\'$momentProvider.definePickerTemplate\\'.')\n    },\n    scope: {\n      dateModel: '=momentPicker',\n      format: '=?',\n      modelFormat: '=?',\n      min: '=?',\n      max: '=?',\n      ngShow: '=?'\n    },\n    controller: ['$scope', '$element', '$attrs', '$parse', '$animate', '$moment',\n      function ($scope, $element, $attr, $parse, $animate, $moment) {\n        var self = this\n\n        self.template = getTemplateDefinition($attr.template)\n        self.format = $moment.$defaultModelFormat\n\n        self.pickedMoment = Number.NaN\n        self.maxMoment = Number.NaN\n        self.minMoment = Number.NaN\n\n        self.visible = true\n        self.hidden = false\n\n        function init () {\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          self.setDisplayMoment($moment())\n          rebuildScopeMoments()\n\n          $scope.weekMoments = []\n          var i = 7\n          while (i--) { $scope.weekMoments.unshift($moment().startOf('week').add(i, 'day')) }\n        }\n\n        // Ctrl Methods\n        // //////////////\n\n        self.setVisibility = function (isVisible) {\n          self.hidden = !isVisible\n          self.visible = !!isVisible\n          $animate[!isVisible ? 'addClass' : 'removeClass']($element, 'ng-hide')\n        }\n\n        self.setPickedMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          if (!isValid) {\n            self.pickedMoment = null\n            $scope.pickedMoment = null\n            return\n          }\n\n          if (self.minMoment && moment.isBefore(self.minMoment, self.template.unit)) { return }\n          if (self.maxMoment && moment.isAfter(self.maxMoment, self.template.unit)) { return }\n\n          // Clamp it to the min/max to keep it valid\n          if (self.minMoment) { moment = moment.min(self.minMoment) }\n          if (self.maxMoment) { moment = moment.max(self.maxMoment) }\n\n          if (moment.isSame(self.pickedMoment)) { return }\n\n          self.pickedMoment = moment.clone()\n          $scope.pickedMoment = moment.clone()\n          $scope.dateModel = moment.format(self.format)\n\n          self.setDisplayMoment(moment)\n        }\n\n        self.setDisplayMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n          var fallbackMoment = self.pickedMoment ? self.pickedMoment : $moment()\n\n          self.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n          $scope.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n\n          rebuildScopeMoments()\n        }\n\n        self.setMinMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.minMoment = isValid ? moment.clone() : null\n        }\n\n        self.setMaxMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.maxMoment = isValid ? moment.clone() : null\n        }\n\n        self.setFormat = function (format) {\n          if (angular.equals(self.format, format)) { return }\n\n          self.format = format || $moment.$defaultModelFormat\n          self.setPickedMoment($scope.dateModel, self.format, $moment.$strictModel)\n        }\n\n        // Watchers\n        // /////////\n\n        $scope.$watch('dateModel', function (modelValue) {\n          self.setPickedMoment(modelValue, self.format, $moment.$strictModel)\n        })\n\n        // Format or modelFormat\n        if ($attr.format && !$attr.modelFormat) {\n          self.format = $scope.format || $moment.$defaultModelFormat\n          $scope.$watch('format', self.setFormat)\n        } else if ($attr.modelFormat) {\n          self.format = $scope.modelFormat || $moment.$defaultModelFormat\n          $scope.$watch('modelFormat', self.setFormat)\n        }\n\n        // Min, Max\n        if ($attr.min) {\n          $scope.$watch('min', function (minValue) {\n            var isArray = angular.isArray(minValue)\n            self.setMinMoment.apply(null, isArray ? minValue : [minValue])\n          }, true)\n        }\n\n        if ($attr.max) {\n          $scope.$watch('max', function (maxValue) {\n            var isArray = angular.isArray(maxValue)\n            self.setMaxMoment.apply(null, isArray ? maxValue : [maxValue])\n          }, true)\n        }\n\n        // Add ctrl methods to the scope that are\n        // suitable for use in the picker template.\n        // /////////////////////////////////////////\n\n        $scope.setPickerVisibility = self.setVisibility\n        $scope.setDisplayMoment = self.setDisplayMoment\n        $scope.setPickedMoment = self.setPickedMoment\n\n        // Private methods\n\n        function rebuildScopeMoments () {\n          var lastMonthMoment = self.displayMoment.clone().startOf('month')\n          var thisMonthMoment = lastMonthMoment.clone()\n          var nextMonthMoment = self.displayMoment.clone().endOf('month')\n          var thisMonth = self.displayMoment.format('M')\n          var thisYear = self.displayMoment.format('YYYY')\n\n          if ($scope.thisMonthMoments.length && thisMonthMoment.isSame($scope.thisMonthMoments[0])) { return }\n\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          while (lastMonthMoment.format('d') !== weekStartDay) { $scope.lastMonthMoments.unshift(lastMonthMoment.subtract(1, 'day').clone()) }\n\n          while (thisMonthMoment.format('M') === thisMonth) {\n            $scope.thisMonthMoments.push(thisMonthMoment.clone())\n            thisMonthMoment.add(1, 'day')\n          }\n\n          while ($scope.lastMonthMoments.length + $scope.thisMonthMoments.length + $scope.nextMonthMoments.length < 42) { $scope.nextMonthMoments.push(nextMonthMoment.add(1, 'day').clone()) }\n\n          while ($scope.monthsThisYearMoments.length < 12) {\n            $scope.monthsThisYearMoments.push($moment({ year: thisYear, month: $scope.monthsThisYearMoments.length }))\n          }\n        }\n\n        init()\n      }\n    ],\n    require: 'momentPicker',\n    link: function (scope, element, attr, ctrl) {\n      // View helpers\n      // //////////////\n\n      scope.getClasses = function (moment, classes) {\n        var isWeekend = /6|7/.test(moment.isoWeekday())\n        var isWeekday = !isWeekend\n        var classObject = {\n          weekend: isWeekend,\n          weekday: isWeekday\n        }\n\n        // Convenience classes: jan fri\n        classObject[ moment.format('MMM ddd').toLowerCase() ] = true\n\n        if (!classes) { return classObject }\n\n        // Iterate over requested class names\n        angular.forEach(classes.split(' '), function (className) {\n          var name = className.split('-')[0]\n          var unit = className.split('-')[1] || ctrl.template.unit\n\n          if (scope.pickedMoment && name === 'picked') {\n            classObject[className] = moment.isSame(scope.pickedMoment, ctrl.template.unit)\n          } else if (name === 'current') {\n            classObject[className + ' current'] = moment.isSame(scope.today, unit)\n          } else if (name === 'invalid' && (ctrl.minMoment || ctrl.maxMoment)) {\n            if (ctrl.minMoment && moment.isBefore(ctrl.minMoment, unit)) {\n              classObject[className + ' invalid'] = true\n            } else if (ctrl.maxMoment && moment.isAfter(ctrl.maxMoment, unit)) {\n              classObject[className + ' invalid'] = true\n            }\n          }\n        })\n\n        return classObject\n      }\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_momentPicker.js\n// module id = 2\n// module chunks = 0","// Picker extends moment input directive with positioned momentPicker\n\nimport angular from 'angular'\nimport { getOffset } from './utils'\n\nexport default ['$moment', '$compile', function inputDirective ($moment, $compile) {\n  var defaultStyleAttr = 'style=\"position:absolute\" class=\"input-picker\"'\n  var copiedAttrs = 'format modelFormat min max'.split(' ')\n\n  var toSpinalCase = function (string) {\n    return string.replace(/[a-z][A-Z]/g, function (w) { return w[0] + '-' + w[1] }).toLowerCase()\n  }\n\n  return {\n    restrict: 'A',\n    require: ['?ngModel'],\n    link: function (scope, element, attr, ctrl) {\n      if (!ctrl || attr.type !== 'moment') { return }\n\n      var pickerAttrs = [ defaultStyleAttr ]\n      var pickerElem, pickerScope, pickerCtrl, deregisterWatch\n\n      function init () {\n        deregisterWatch()\n        pickerScope = pickerElem.isolateScope()\n        pickerCtrl = pickerElem.controller('momentPicker')\n        pickerCtrl.setVisibility(false)\n        pickerScope.showClose = true\n      }\n\n      // Copy relevent attrs from input to picker\n      if (attr.picker) { pickerAttrs.push('template=' + attr.picker) }\n\n      angular.forEach(copiedAttrs, function (name) {\n        if (attr[name]) { pickerAttrs.push(toSpinalCase(name) + '=\"' + attr[name] + '\"') }\n      })\n\n      // Compile/inject/bind events to picker\n      pickerElem = $compile('<div moment-picker=\"' + attr.ngModel + '\" ' + pickerAttrs.join(' ') + '></div>')(scope)\n\n      // Watch for controller instantiation\n      deregisterWatch = scope.$watch(function () {\n        if (pickerElem.controller('momentPicker')) { init() }\n      })\n\n      // DOM manipulation and event watching\n      angular.element(document.body).append(pickerElem)\n\n      pickerElem.on('mousedown', function (event) {\n        event.preventDefault()\n      })\n\n      // Input event binding\n      element.on('focus click', function (event) {\n        var offset = getOffset(element[0])\n\n        pickerElem.css({\n          left: offset.left + 'px',\n          top: offset.bottom + 'px'\n        })\n\n        pickerCtrl.setVisibility(true)\n      })\n\n      element.on('blur keydown', function (event) {\n        if (event.type === 'keydown' && event.which !== 27) { return }\n        pickerCtrl.setVisibility(false)\n      })\n\n      // Destruction cleanup\n      scope.$on('$destroy', function () {\n        pickerElem.off().remove()\n      })\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_picker.js\n// module id = 3\n// module chunks = 0","import angular from 'angular'\n\nexport default ['$moment', function ($moment) {\n  // Format: String or Array\n  // String: Moment output format (defaults to defaultViewFormat)\n  // Array: Moment input format, moment output format, [strict]\n  return function momentFormatFilter (date, format) {\n    var moment, strict, inputFormat\n    var outputFormat = $moment.$defaultViewFormat\n\n    if (!angular.isDefined(date)) { return date }\n\n    if (angular.isString(format)) { outputFormat = format } else if (angular.isArray(format)) {\n      inputFormat = format[0]\n      outputFormat = format[1] || outputFormat\n      strict = format[2]\n    }\n\n    moment = $moment(date, inputFormat, strict)\n\n    if (moment.isValid()) { return moment.format(outputFormat) }\n\n    // Try parsing it with the defaultModelFormat if inputFormat wasn't specified\n    if (!angular.isDefined(inputFormat)) {\n      moment = $moment(date, $moment.$defaultModelFormat, $moment.strictModel)\n      if (moment.isValid()) { return moment.format(outputFormat) }\n    }\n\n    return date\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/filter.js\n// module id = 4\n// module chunks = 0","import angular from 'angular'\nimport moment from 'moment'\n\nexport default function $momentProvider () {\n  // Strict parsing has trouble in Moment.js v2.32.5 with short tokens\n  // E.g. 1-31-2000, M-D-YYYY is invalid.\n  var config = {\n    $$pickerTemplates: {},\n    $strictView: true,\n    $strictModel: true,\n    $defaultViewFormat: 'L',\n    $defaultModelFormat: moment.defaultFormat,\n    $parseFormat: $parseFormat\n  }\n\n  // For parsing locale-dependent date formats (L, LL, etc.)\n  function $parseFormat (format) {\n    format = format || ''\n    if (format.match(/l/i)) { return moment().lang()._longDateFormat[format] || format }\n    return format\n  }\n\n  this.defaultViewFormat = function (format) {\n    if (angular.isString(format)) { config.$defaultViewFormat = format }\n    return this\n  }\n\n  this.defaultModelFormat = function (format) {\n    if (angular.isString(format)) { config.$defaultModelFormat = format }\n    return this\n  }\n\n  this.strictView = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictView = bool }\n    return this\n  }\n\n  this.strictModel = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictModel = bool }\n    return this\n  }\n\n  this.definePickerTemplate = function (template) {\n    if (angular.isObject(template) && template.name && template.url) {\n      config.$$pickerTemplates[template.name] = {\n        url: template.url,\n        unit: template.unit || 'days'\n      }\n    }\n    return this\n  }\n\n  this.$get = function () {\n    if (angular.isDefined(moment.$strictView)) { return moment }\n    try {\n      Object.defineProperty(moment, '$strictView', {\n        value: config.$strictView\n      })\n      Object.defineProperty(moment, '$strictModel', {\n        value: config.$strictModel\n      })\n      Object.defineProperty(moment, '$defaultViewFormat', {\n        value: config.$defaultViewFormat\n      })\n      Object.defineProperty(moment, '$defaultModelFormat', {\n        value: config.$defaultModelFormat\n      })\n      Object.defineProperty(moment, '$parseFormat', {\n        value: config.$parseFormat\n      })\n      Object.defineProperty(moment, '$$pickerTemplates', {\n        value: angular.copy(config.$$pickerTemplates),\n        writable: true\n      })\n    } catch (err) { angular.extend(moment, config) }\n    return moment\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/service.js\n// module id = 5\n// module chunks = 0","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/indexof/index.js\n// module id = 6\n// module chunks = 0","export {getOffset}\n\nfunction getOffset (elem) {\n  // Based on http://stackoverflow.com/a/8111175\n  if (!elem) { return }\n\n  var doc = document\n  var win = window\n  var bodyElem = doc.body\n  var docElem = doc.documentElement\n  var boxElem = doc.createElement('div')\n  var isBoxModel,\n    clientTop, clientLeft,\n    scrollTop, scrollLeft,\n    offsetTop, offsetRight, offsetBottom, offsetLeft,\n    adjustedScrollTop,\n    adjustedScrollLeft\n\n  boxElem.style.paddingLeft =\n  boxElem.style.width = '1px'\n\n  bodyElem.appendChild(boxElem)\n  isBoxModel = boxElem.offsetWidth === 2\n  bodyElem.removeChild(boxElem)\n  boxElem = elem.getBoundingClientRect()\n\n  clientTop = docElem.clientTop || bodyElem.clientTop || 0\n  clientLeft = docElem.clientLeft || bodyElem.clientLeft || 0\n  scrollTop = win.pageYOffset || isBoxModel && docElem.scrollTop || bodyElem.scrollTop\n  scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || bodyElem.scrollLeft\n\n  adjustedScrollTop = scrollTop - clientTop\n  adjustedScrollLeft = scrollLeft - clientLeft\n\n  offsetTop = boxElem.top + adjustedScrollTop\n  offsetLeft = boxElem.left + adjustedScrollLeft\n  offsetBottom = boxElem.bottom + adjustedScrollTop\n  offsetRight = boxElem.right + adjustedScrollLeft\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetBottom,\n    right: offsetRight\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 8\n// module chunks = 0","import angular from 'angular'\n\nimport service from './service'\nimport filter from './filter'\nimport inputDirective from './directive_input'\nimport momentPickerDirective from './directive_momentPicker'\nimport pickerDirective from './directive_picker'\n\nexport default angular\n  .module('$moment', [])\n  .provider('$moment', service)\n  .filter('momentFormat', filter)\n  .directive('input', inputDirective)\n  .directive('picker', pickerDirective)\n  .directive('momentPicker', momentPickerDirective)\n  .name\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}