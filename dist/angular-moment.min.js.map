{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///angular-moment.min.js","webpack:///webpack/bootstrap c2f5f96a8870be363408","webpack:///external \"angular\"","webpack:///./src/directive_input.js","webpack:///./src/directive_inputPicker.js","webpack:///./src/directive_picker.js","webpack:///./src/filter.js","webpack:///./src/service.js","webpack:///./~/indexof/index.js","webpack:///./src/utils.js","webpack:///external \"moment\"","webpack:///./src/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_angular__","__WEBPACK_IMPORTED_MODULE_0_angular___default","__WEBPACK_IMPORTED_MODULE_1_indexof__","__WEBPACK_IMPORTED_MODULE_1_indexof___default","$moment","$timeout","stepUnits","strictView","$strictView","strictModel","$strictModel","priority","restrict","compile","tElement","tAttr","type","a","noop","scope","element","attr","ctrl","momentValue","stepUnit","stepQuantity","viewFormat","$defaultViewFormat","modelFormat","$defaultModelFormat","hasFocus","moments","min","view","model","max","setPlaceholder","format","$parseFormat","reparseOrReformatValue","hasModelValue","$isEmpty","$modelValue","hasViewValue","$viewValue","reformatModelValue","reparseViewValue","$setViewValue","modelValue","$apply","ngModel","setViewModelMomentsForAttr","isValid","parseValidateAndFormatDate","origin","moment","isEmpty","inputFormat","outputFormat","strict","clone","$setValidity","isBefore","isAfter","$error","$parsers","push","bind","undefined","$formatters","$eval","$watch","minWatchAction","minAttr","isArray","length","isString","maxWatchAction","maxAttr","step","match","parseInt","inputStepHandler","event","eventData","extend","test","which","preventDefault","wheelDelta","isIncrease","shiftedStepUnit","momentViewStepped","steppedViewValue","isViewEmpty","momentView","originalEvent","shiftKey","replace","add","subtract","$render","on","e","$log","weekStartDay","startOf","getTemplateDefinition","templateName","$$pickerTemplates","templateUrl","tAttrs","template","url","error","dateModel","ngShow","controller","$scope","$element","$attr","$parse","$animate","init","today","lastMonthMoments","thisMonthMoments","nextMonthMoments","monthsThisYearMoments","self","setDisplayMoment","rebuildScopeMoments","weekMoments","unshift","lastMonthMoment","displayMoment","thisMonthMoment","nextMonthMoment","endOf","thisMonth","thisYear","isSame","year","month","pickedMoment","Number","NaN","maxMoment","minMoment","visible","hidden","setVisibility","isVisible","setPickedMoment","input","lang","apply","arguments","unit","fallbackMoment","setMinMoment","setMaxMoment","setFormat","equals","minValue","maxValue","setPickerVisibility","link","getClasses","classes","isWeekend","isoWeekday","isWeekday","classObject","weekend","weekday","toLowerCase","forEach","split","className","__WEBPACK_IMPORTED_MODULE_1__utils__","$compile","defaultStyleAttr","copiedAttrs","toSpinalCase","string","w","deregisterWatch","pickerScope","pickerElem","isolateScope","pickerCtrl","showClose","pickerAttrs","picker","join","document","body","append","offset","css","left","top","bottom","$on","off","remove","date","isDefined","$momentProvider","__WEBPACK_IMPORTED_MODULE_1_moment___default","_longDateFormat","config","defaultFormat","defaultViewFormat","defaultModelFormat","bool","definePickerTemplate","isObject","$get","copy","writable","err","__WEBPACK_IMPORTED_MODULE_1_moment__","indexOf","arr","obj","getOffset","elem","isBoxModel","clientTop","clientLeft","scrollTop","scrollLeft","offsetTop","offsetRight","offsetBottom","offsetLeft","adjustedScrollTop","adjustedScrollLeft","doc","win","window","bodyElem","docElem","documentElement","boxElem","createElement","style","paddingLeft","width","appendChild","offsetWidth","removeChild","getBoundingClientRect","pageYOffset","pageXOffset","right","__WEBPACK_IMPORTED_MODULE_1__service__","__WEBPACK_IMPORTED_MODULE_2__filter__","__WEBPACK_IMPORTED_MODULE_3__directive_input__","__WEBPACK_IMPORTED_MODULE_4__directive_inputPicker__","__WEBPACK_IMPORTED_MODULE_5__directive_picker__","provider","filter","directive"],"mappings":"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","file":"angular-moment.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$moment\"] = factory(require(\"angular\"), require(\"moment\"));\n\telse\n\t\troot[\"$moment\"] = factory(root[\"angular\"], root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$moment\"] = factory(require(\"angular\"), require(\"moment\"));\n\telse\n\t\troot[\"$moment\"] = factory(root[\"angular\"], root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_indexof__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_indexof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_indexof__);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$timeout', function inputDirective ($moment, $timeout) {\n  // Maybe expose a setting for localization someday...\n  var stepUnits = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year']\n  var strictView = $moment.$strictView\n  var strictModel = $moment.$strictModel\n\n  return {\n    priority: 10,\n    restrict: 'E',\n    require: '?ngModel',\n    compile: function inputCompile (tElement, tAttr) {\n      // Support both input[type=date] and input[type=moment] so one can use type=moment if\n      // browser vendor type=date functionality is undesired (*ehem* Chrome).\n      if (tAttr.type !== 'date' && tAttr.type !== 'moment') { return __WEBPACK_IMPORTED_MODULE_0_angular___default.a.noop }\n      return function inputPostLink (scope, element, attr, ctrl) {\n        // All the functionality of this directive requires ngModelCtrl.\n        if (!ctrl) { return }\n\n        // A Moment of the last value passed through the directive's validator. Allows\n        // stepping function to not have to reparse ctrl.$viewValue and potentially fail\n        // if another directive's formatter has changed the view value format.\n        var momentValue\n            // Formats may be overridden if attr.(view|model)Format or attr.format is set.\n        var viewFormat = $moment.$defaultViewFormat\n        var modelFormat = $moment.$defaultModelFormat\n        var stepUnit, stepQuantity\n            // We track focus state to prevent stepping if elem is blurred.\n        var hasFocus = false\n            // Min/max must be reparsed using view/model formats to account for differences\n            // in date specificity. E.g., if min is '01-30-2000' and viewFormat is 'MM-YYYY'\n            // and the model value is '01-2000'.\n        var moments = {\n          min: {\n            attr: null,\n            view: null,\n            model: null\n          },\n          max: {\n            attr: null,\n            view: null,\n            model: null\n          }\n        }\n\n        // Utility Functions\n        // ///////////////////\n\n        var setPlaceholder = function (format) {\n          if (!element.attr('placeholder')) { element.attr('placeholder', $moment.$parseFormat(format)) }\n        }\n\n        var reparseOrReformatValue = function () {\n          var hasModelValue = !ctrl.$isEmpty(ctrl.$modelValue)\n          var hasViewValue = !ctrl.$isEmpty(ctrl.$viewValue)\n\n          if (hasModelValue) { reformatModelValue() } else if (hasViewValue) { reparseViewValue() }\n        }\n\n        var reparseViewValue = function () {\n          if (!ctrl.$isEmpty(ctrl.$viewValue)) { ctrl.$setViewValue(ctrl.$viewValue) }\n        }\n        var reformatModelValue = function () {\n          // Is there a better way to resend the model value through the formatter pipeline?\n          var modelValue = ctrl.$modelValue\n          if (!ctrl.$isEmpty(modelValue)) {\n            $timeout(function () {\n              scope.$apply(function () { scope[attr.ngModel] = modelValue + ' ' })\n              scope.$apply(function () { scope[attr.ngModel] = modelValue })\n            }, 0, false)\n          }\n        }\n\n        var setViewModelMomentsForAttr = function (attr) {\n          // attr is either 'min' or 'max'\n          if (moments[attr].attr && moments[attr].attr.isValid()) {\n            moments[attr].view = $moment(moments[attr].attr.format(viewFormat), viewFormat)\n            moments[attr].model = $moment(moments[attr].attr.format(modelFormat), modelFormat)\n          } else { moments[attr].attr = moments[attr].view = moments[attr].model = null }\n        }\n\n        // Date Validation and Formatting\n        // ////////////////////////////////\n\n        var parseValidateAndFormatDate = function parseValidateAndFormatDate (origin, value) {\n          var moment, isValid, isEmpty, inputFormat, outputFormat, strict\n\n          if (origin === 'view') {\n            inputFormat = viewFormat\n            outputFormat = modelFormat\n            strict = strictView\n          } else {\n            inputFormat = modelFormat\n            outputFormat = viewFormat\n            strict = strictModel\n          }\n\n          moment = $moment(value, inputFormat, strict)\n          isValid = moment.isValid()\n          isEmpty = ctrl.$isEmpty(value)\n          momentValue = isEmpty ? $moment(null) : moment.clone()\n\n          // Date validation\n          if (!isEmpty && !isValid) {\n            ctrl.$setValidity('date', false)\n            if (attr.min) ctrl.$setValidity('min', true)\n            if (attr.max) ctrl.$setValidity('max', true)\n            return undefined\n          } else { ctrl.$setValidity('date', true) }\n\n          // Min validation\n          if (attr.min) {\n            if (!isEmpty && isValid && moments.min.attr && moment.isBefore(moments.min[origin])) { ctrl.$setValidity('min', false) } else { ctrl.$setValidity('min', true) }\n          }\n\n          // Max validation\n          if (attr.max) {\n            if (!isEmpty && isValid && moments.max.attr && moment.isAfter(moments.max[origin])) { ctrl.$setValidity('max', false) } else { ctrl.$setValidity('max', true) }\n          }\n\n          // Output and formatting\n          if (ctrl.$error.min || ctrl.$error.max) { return undefined } else { return isEmpty ? value : moment.format(outputFormat) }\n        }\n\n        ctrl.$parsers.push(__WEBPACK_IMPORTED_MODULE_0_angular___default.a.bind(undefined, parseValidateAndFormatDate, 'view'))\n        ctrl.$formatters.push(__WEBPACK_IMPORTED_MODULE_0_angular___default.a.bind(undefined, parseValidateAndFormatDate, 'model'))\n\n        // Process format, viewFormat, modelFormat attrs\n        // ///////////////////////////////////////////////\n\n        if (attr.format && (!attr.viewFormat || !attr.modelFormat)) {\n          viewFormat = scope.$eval(attr.format) || viewFormat\n          modelFormat = scope.$eval(attr.format) || modelFormat\n\n          scope.$watch(attr.format, function formatWatchAction (value) {\n            viewFormat = value\n            modelFormat = value\n            setPlaceholder(value)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        if (attr.viewFormat) {\n          viewFormat = scope.$eval(attr.viewFormat) || viewFormat\n\n          scope.$watch(attr.viewFormat, function viewFormatWatchAction (format) {\n            format = format || $moment.$defaultViewFormat\n            if (format === viewFormat) return\n            viewFormat = format\n            setPlaceholder(format)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reformatModelValue()\n          })\n        }\n\n        if (attr.modelFormat) {\n          modelFormat = scope.$eval(attr.modelFormat) || modelFormat\n\n          scope.$watch(attr.modelFormat, function modelFormatWatchAction (format) {\n            format = format || $moment.$defaultModelFormat\n            if (format === modelFormat) return\n            modelFormat = format\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        setPlaceholder(viewFormat)\n\n        // Min/Max Validation\n        // ////////////////////\n\n        var minWatchAction = function minWatchAction (minAttr) {\n          var moment\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(minAttr) && minAttr.length === 2) { moment = $moment(minAttr[0], minAttr[1]) } else if (minAttr && __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(minAttr)) {\n            if (minAttr === 'today') { moment = $moment() } else { moment = $moment(minAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n          // Has the min changed?\n          if (!moment ^ !moments.min.attr || (moment && moments.min.attr && moment.format('X') !== moments.min.attr.format('X'))) {\n            moments.min.attr = moment\n            setViewModelMomentsForAttr('min')\n            reparseOrReformatValue()\n          }\n        }\n\n        minWatchAction(scope.$eval(attr.min))\n        scope.$watch(function () {\n          return scope.$eval(attr.min)\n        }, minWatchAction, true)\n\n        var maxWatchAction = function maxWatchAction (maxAttr) {\n          var moment\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(maxAttr) && maxAttr.length === 2) { moment = $moment(maxAttr[0], maxAttr[1]) } else if (maxAttr && __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(maxAttr)) {\n            if (maxAttr === 'today') { moment = $moment() } else { moment = $moment(maxAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n\n          if (!moment ^ !moments.max.attr || (moment && moments.max.attr && moment.format('X') !== moments.max.attr.format('X'))) {\n            moments.max.attr = moment\n            setViewModelMomentsForAttr('max')\n            reparseOrReformatValue()\n          }\n        }\n\n        maxWatchAction(scope.$eval(attr.max))\n        scope.$watch(function () {\n          return scope.$eval(attr.max)\n        }, maxWatchAction, true)\n\n        // Stepping\n        // //////////\n\n        // TODO: Allow this to be config'ed\n        stepUnit = 'day'\n        stepQuantity = 1\n\n        if (attr.step) {\n          scope.$watch(attr.step, function stepWatchAction (step) {\n            if (!step || !__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(step)) { return }\n\n            var match = step.match(/(\\d+)\\s(\\w+)/)\n            if (match) {\n              stepUnit = match[2]\n              stepQuantity = parseInt(match[1], 10)\n            } else {\n              stepUnit = 'day'\n              stepQuantity = 1\n            }\n          })\n        }\n\n        var inputStepHandler = function (event, eventData) {\n          // Allow for passing custom event object in tests (so Kosher)\n          // TODO: Use gulp-remove-lines to strip this from build\n          if (!event.type && eventData && eventData.type) {\n            __WEBPACK_IMPORTED_MODULE_0_angular___default.a.extend(event, eventData)\n            hasFocus = true\n          }\n\n          if (element.attr('readonly')) { return }\n\n          //                               Up|Dn\n          if (!hasFocus || (event.type === 'keydown' && !/38|40/.test(event.which))) return\n          event.preventDefault()\n\n          var isViewEmpty = ctrl.$isEmpty(ctrl.$viewValue)\n          var momentView = isViewEmpty ? $moment() : $moment(momentValue.format(viewFormat), viewFormat, true)\n          var wheelDelta, isIncrease, shiftedStepUnit, momentViewStepped, steppedViewValue\n\n          if (!momentView.isValid()) { return }\n\n          if (event.type === 'keydown') { isIncrease = /38/.test(event.which) } else {\n            wheelDelta = event.originalEvent ? event.originalEvent.wheelDelta : event.wheelDelta\n            isIncrease = wheelDelta / 120 > 0\n          }\n\n          if (event.shiftKey) {\n            shiftedStepUnit = stepUnits[(__WEBPACK_IMPORTED_MODULE_1_indexof___default()(stepUnits, stepUnit.replace(/s$/, '')) + 1)] || stepUnit\n          } else shiftedStepUnit = stepUnit\n\n          if (isViewEmpty && moments.min.attr) {\n            // Always step an empty value to the min if specified\n            momentViewStepped = moments.min.view.clone()\n          } else if (isIncrease) {\n            if (isViewEmpty && !moments.min.attr) {\n              // Then use today's date clamped to max\n              momentViewStepped = momentView.max(moments.max.attr ? moments.max.view : undefined)\n            } else if (moments.min.attr && momentView.isBefore(moments.min.view)) {\n              momentViewStepped = moments.min.view.clone()\n            } else if (moments.max.attr && !momentView.isAfter(moments.max.view)) {\n              // Then step value up, clamp to max\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity).max(moments.max.view)\n            } else if (!moments.max.attr) {\n              // If there's no max, increase; otherwise leave it exceeding max--we'll only bring it\n              // back in bounds of the max when user decreases value.\n              // This mimic's browser vendor behavior with min/max stepping for input[type=number]\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity)\n            }\n          } else {\n            // The opposite for decrease\n            if (isViewEmpty && !moments.max.attr) {\n              momentViewStepped = momentView.min(moments.min.attr ? moments.min.view : undefined)\n            } else if (moments.max.attr && momentView.isAfter(moments.max.view)) {\n              momentViewStepped = moments.max.view.clone()\n            } else if (moments.min.attr && !momentView.isBefore(moments.min.view)) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity).min(moments.min.view)\n            } else if (!moments.min.attr) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity)\n            }\n          }\n\n          steppedViewValue = (momentViewStepped || momentView).format(viewFormat)\n\n          scope.$apply(function () {\n            ctrl.$setViewValue(steppedViewValue)\n            ctrl.$render()\n          })\n        }\n\n        element.on('mousewheel keydown', inputStepHandler)\n\n        element.on('focus', function (e) { hasFocus = true })\n        element.on('blur', function (e) { hasFocus = false })\n      }\n    }\n  }\n}];\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$log', function inputDirective ($moment, $log) {\n  var weekStartDay = $moment().startOf('week').format('d')\n  // var weekEndDay = $moment().endOf('week').format('d')\n  var getTemplateDefinition = function (templateName) {\n    return $moment.$$pickerTemplates[templateName || 'default']\n  }\n\n  return {\n    restrict: 'A',\n    templateUrl: function (tElement, tAttrs) {\n      var template = getTemplateDefinition(tAttrs.template)\n      if (template) { return template.url }\n      // Ya dun' goofed.\n      $log.error('Error: [momentDatepicker] Picker template \\'' + tAttrs.template + '\\' is undefined. Templates must be defined with \\'$momentProvider.definePickerTemplate\\'.')\n    },\n    scope: {\n      dateModel: '=momentPicker',\n      format: '=?',\n      modelFormat: '=?',\n      min: '=?',\n      max: '=?',\n      ngShow: '=?'\n    },\n    controller: ['$scope', '$element', '$attrs', '$parse', '$animate', '$moment',\n      function ($scope, $element, $attr, $parse, $animate, $moment) {\n        var self = this\n\n        self.template = getTemplateDefinition($attr.template)\n        self.format = $moment.$defaultModelFormat\n\n        self.pickedMoment = Number.NaN\n        self.maxMoment = Number.NaN\n        self.minMoment = Number.NaN\n\n        self.visible = true\n        self.hidden = false\n\n        function init () {\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          self.setDisplayMoment($moment())\n          rebuildScopeMoments()\n\n          $scope.weekMoments = []\n          var i = 7\n          while (i--) { $scope.weekMoments.unshift($moment().startOf('week').add(i, 'day')) }\n        }\n\n        // Ctrl Methods\n        // //////////////\n\n        self.setVisibility = function (isVisible) {\n          self.hidden = !isVisible\n          self.visible = !!isVisible\n          $animate[!isVisible ? 'addClass' : 'removeClass']($element, 'ng-hide')\n        }\n\n        self.setPickedMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          if (!isValid) {\n            self.pickedMoment = null\n            $scope.pickedMoment = null\n            return\n          }\n\n          if (self.minMoment && moment.isBefore(self.minMoment, self.template.unit)) { return }\n          if (self.maxMoment && moment.isAfter(self.maxMoment, self.template.unit)) { return }\n\n          // Clamp it to the min/max to keep it valid\n          if (self.minMoment) { moment = moment.min(self.minMoment) }\n          if (self.maxMoment) { moment = moment.max(self.maxMoment) }\n\n          if (moment.isSame(self.pickedMoment)) { return }\n\n          self.pickedMoment = moment.clone()\n          $scope.pickedMoment = moment.clone()\n          $scope.dateModel = moment.format(self.format)\n\n          self.setDisplayMoment(moment)\n        }\n\n        self.setDisplayMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n          var fallbackMoment = self.pickedMoment ? self.pickedMoment : $moment()\n\n          self.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n          $scope.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n\n          rebuildScopeMoments()\n        }\n\n        self.setMinMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.minMoment = isValid ? moment.clone() : null\n        }\n\n        self.setMaxMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.maxMoment = isValid ? moment.clone() : null\n        }\n\n        self.setFormat = function (format) {\n          if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.equals(self.format, format)) { return }\n\n          self.format = format || $moment.$defaultModelFormat\n          self.setPickedMoment($scope.dateModel, self.format, $moment.$strictModel)\n        }\n\n        // Watchers\n        // /////////\n\n        $scope.$watch('dateModel', function (modelValue) {\n          self.setPickedMoment(modelValue, self.format, $moment.$strictModel)\n        })\n\n        // Format or modelFormat\n        if ($attr.format && !$attr.modelFormat) {\n          self.format = $scope.format || $moment.$defaultModelFormat\n          $scope.$watch('format', self.setFormat)\n        } else if ($attr.modelFormat) {\n          self.format = $scope.modelFormat || $moment.$defaultModelFormat\n          $scope.$watch('modelFormat', self.setFormat)\n        }\n\n        // Min, Max\n        if ($attr.min) {\n          $scope.$watch('min', function (minValue) {\n            var isArray = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(minValue)\n            self.setMinMoment.apply(null, isArray ? minValue : [minValue])\n          }, true)\n        }\n\n        if ($attr.max) {\n          $scope.$watch('max', function (maxValue) {\n            var isArray = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(maxValue)\n            self.setMaxMoment.apply(null, isArray ? maxValue : [maxValue])\n          }, true)\n        }\n\n        // Add ctrl methods to the scope that are\n        // suitable for use in the picker template.\n        // /////////////////////////////////////////\n\n        $scope.setPickerVisibility = self.setVisibility\n        $scope.setDisplayMoment = self.setDisplayMoment\n        $scope.setPickedMoment = self.setPickedMoment\n\n        // Private methods\n\n        function rebuildScopeMoments () {\n          var lastMonthMoment = self.displayMoment.clone().startOf('month')\n          var thisMonthMoment = lastMonthMoment.clone()\n          var nextMonthMoment = self.displayMoment.clone().endOf('month')\n          var thisMonth = self.displayMoment.format('M')\n          var thisYear = self.displayMoment.format('YYYY')\n\n          if ($scope.thisMonthMoments.length && thisMonthMoment.isSame($scope.thisMonthMoments[0])) { return }\n\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          while (lastMonthMoment.format('d') !== weekStartDay) { $scope.lastMonthMoments.unshift(lastMonthMoment.subtract(1, 'day').clone()) }\n\n          while (thisMonthMoment.format('M') === thisMonth) {\n            $scope.thisMonthMoments.push(thisMonthMoment.clone())\n            thisMonthMoment.add(1, 'day')\n          }\n\n          while ($scope.lastMonthMoments.length + $scope.thisMonthMoments.length + $scope.nextMonthMoments.length < 42) { $scope.nextMonthMoments.push(nextMonthMoment.add(1, 'day').clone()) }\n\n          while ($scope.monthsThisYearMoments.length < 12) {\n            $scope.monthsThisYearMoments.push(\n              $moment({ year: thisYear, month: $scope.monthsThisYearMoments.length })\n            )\n          }\n        }\n\n        init()\n      }\n    ],\n    require: 'momentPicker',\n    link: function (scope, element, attr, ctrl) {\n      // View helpers\n      // //////////////\n\n      scope.getClasses = function (moment, classes) {\n        var isWeekend = /6|7/.test(moment.isoWeekday())\n        var isWeekday = !isWeekend\n        var classObject = {\n          weekend: isWeekend,\n          weekday: isWeekday\n        }\n\n        // Convenience classes: jan fri\n        classObject[ moment.format('MMM ddd').toLowerCase() ] = true\n\n        if (!classes) { return classObject }\n\n        // Iterate over requested class names\n        __WEBPACK_IMPORTED_MODULE_0_angular___default.a.forEach(classes.split(' '), function (className) {\n          var name = className.split('-')[0]\n          var unit = className.split('-')[1] || ctrl.template.unit\n\n          if (scope.pickedMoment && name === 'picked') { classObject[className] = moment.isSame(scope.pickedMoment, ctrl.template.unit) } else if (name === 'current') { classObject[className + ' current'] = moment.isSame(scope.today, unit) } else if (name === 'invalid' && (ctrl.minMoment || ctrl.maxMoment)) {\n            if (ctrl.minMoment && moment.isBefore(ctrl.minMoment, unit)) { classObject[className + ' invalid'] = true } else if (ctrl.maxMoment && moment.isAfter(ctrl.maxMoment, unit)) { classObject[className + ' invalid'] = true }\n          }\n        })\n\n        return classObject\n      }\n    }\n  }\n}];\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(7);\n// Picker extends moment input directive with positioned momentPicker\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', '$compile', function inputDirective ($moment, $compile) {\n  var defaultStyleAttr = 'style=\"position:absolute\" class=\"input-picker\"'\n  var copiedAttrs = 'format modelFormat min max'.split(' ')\n\n  var toSpinalCase = function (string) {\n    return string.replace(/[a-z][A-Z]/g, function (w) { return w[0] + '-' + w[1] }).toLowerCase()\n  }\n\n  return {\n    restrict: 'A',\n    require: ['?ngModel'],\n    link: function (scope, element, attr, ctrl) {\n      if (!ctrl || attr.type !== 'moment') { return }\n\n      var pickerAttrs = [ defaultStyleAttr ]\n      var pickerElem, pickerScope, pickerCtrl, deregisterWatch\n\n      function init () {\n        deregisterWatch()\n        pickerScope = pickerElem.isolateScope()\n        pickerCtrl = pickerElem.controller('momentPicker')\n        pickerCtrl.setVisibility(false)\n        pickerScope.showClose = true\n      }\n\n      // Copy relevent attrs from input to picker\n      if (attr.picker) { pickerAttrs.push('template=' + attr.picker) }\n\n      __WEBPACK_IMPORTED_MODULE_0_angular___default.a.forEach(copiedAttrs, function (name) {\n        if (attr[name]) { pickerAttrs.push(toSpinalCase(name) + '=\"' + attr[name] + '\"') }\n      })\n\n      // Compile/inject/bind events to picker\n      pickerElem = $compile('<div moment-picker=\"' + attr.ngModel + '\" ' + pickerAttrs.join(' ') + '></div>')(scope)\n\n      // Watch for controller instantiation\n      deregisterWatch = scope.$watch(function () {\n        if (pickerElem.controller('momentPicker')) { init() }\n      })\n\n      // DOM manipulation and event watching\n      __WEBPACK_IMPORTED_MODULE_0_angular___default.a.element(document.body).append(pickerElem)\n\n      pickerElem.on('mousedown', function (event) {\n        event.preventDefault()\n      })\n\n      // Input event binding\n      element.on('focus click', function (event) {\n        var offset = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getOffset */])(element[0])\n\n        pickerElem.css({\n          left: offset.left + 'px',\n          top: offset.bottom + 'px'\n        })\n\n        pickerCtrl.setVisibility(true)\n      })\n\n      element.on('blur keydown', function (event) {\n        if (event.type === 'keydown' && event.which !== 27) { return }\n        pickerCtrl.setVisibility(false)\n      })\n\n      // Destruction cleanup\n      scope.$on('$destroy', function () {\n        pickerElem.off().remove()\n      })\n    }\n  }\n}];\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ['$moment', function ($moment) {\n  // Format: String or Array\n  // String: Moment output format (defaults to defaultViewFormat)\n  // Array: Moment input format, moment output format, [strict]\n  return function momentFormatFilter (date, format) {\n    var moment, strict, inputFormat,\n      outputFormat = $moment.$defaultViewFormat\n\n    if (!__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(date)) { return date }\n\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { outputFormat = format } else if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isArray(format)) {\n      inputFormat = format[0]\n      outputFormat = format[1] || outputFormat\n      strict = format[2]\n    }\n\n    moment = $moment(date, inputFormat, strict)\n\n    if (moment.isValid()) { return moment.format(outputFormat) }\n\n    // Try parsing it with the defaultModelFormat if inputFormat wasn't specified\n    if (!__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(inputFormat)) {\n      moment = $moment(date, $moment.$defaultModelFormat, $moment.strictModel)\n      if (moment.isValid()) { return moment.format(outputFormat) }\n    }\n\n    return date\n  }\n}];\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = $momentProvider;\n\n\n\nfunction $momentProvider () {\n  // Strict parsing has trouble in Moment.js v2.32.5 with short tokens\n  // E.g. 1-31-2000, M-D-YYYY is invalid.\n  var config = {\n    $$pickerTemplates: {},\n    $strictView: true,\n    $strictModel: true,\n    $defaultViewFormat: 'L',\n    $defaultModelFormat: __WEBPACK_IMPORTED_MODULE_1_moment___default.a.defaultFormat,\n    $parseFormat: $parseFormat\n  }\n\n  // For parsing locale-dependent date formats (L, LL, etc.)\n  function $parseFormat (format) {\n    format = format || ''\n    if (format.match(/l/i)) { return __WEBPACK_IMPORTED_MODULE_1_moment___default()().lang()._longDateFormat[format] || format }\n    return format\n  }\n\n  this.defaultViewFormat = function (format) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { config.$defaultViewFormat = format }\n    return this\n  }\n\n  this.defaultModelFormat = function (format) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(format)) { config.$defaultModelFormat = format }\n    return this\n  }\n\n  this.strictView = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictView = bool }\n    return this\n  }\n\n  this.strictModel = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictModel = bool }\n    return this\n  }\n\n  this.definePickerTemplate = function (template) {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isObject(template) && template.name && template.url) {\n      config.$$pickerTemplates[template.name] = {\n        url: template.url,\n        unit: template.unit || 'days'\n      }\n    }\n    return this\n  }\n\n  this.$get = function () {\n    if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isDefined(__WEBPACK_IMPORTED_MODULE_1_moment___default.a.$strictView)) { return __WEBPACK_IMPORTED_MODULE_1_moment___default.a }\n    try {\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$strictView', {\n        value: config.$strictView\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$strictModel', {\n        value: config.$strictModel\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$defaultViewFormat', {\n        value: config.$defaultViewFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$defaultModelFormat', {\n        value: config.$defaultModelFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$parseFormat', {\n        value: config.$parseFormat\n      })\n      Object.defineProperty(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, '$$pickerTemplates', {\n        value: __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(config.$$pickerTemplates),\n        writable: true\n      })\n    } catch (err) { __WEBPACK_IMPORTED_MODULE_0_angular___default.a.extend(__WEBPACK_IMPORTED_MODULE_1_moment___default.a, config) }\n    return __WEBPACK_IMPORTED_MODULE_1_moment___default.a\n  }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getOffset; });\n\n\nfunction getOffset (elem) {\n  // Based on http://stackoverflow.com/a/8111175\n  if (!elem) { return }\n\n  var doc = document\n  var win = window\n  var bodyElem = doc.body\n  var docElem = doc.documentElement\n  var boxElem = doc.createElement('div')\n  var isBoxModel,\n    clientTop, clientLeft,\n    scrollTop, scrollLeft,\n    offsetTop, offsetRight, offsetBottom, offsetLeft,\n    adjustedScrollTop,\n    adjustedScrollLeft\n\n  boxElem.style.paddingLeft =\n  boxElem.style.width = '1px'\n\n  bodyElem.appendChild(boxElem)\n  isBoxModel = boxElem.offsetWidth == 2\n  bodyElem.removeChild(boxElem)\n  boxElem = elem.getBoundingClientRect()\n\n  clientTop = docElem.clientTop || bodyElem.clientTop || 0\n  clientLeft = docElem.clientLeft || bodyElem.clientLeft || 0\n  scrollTop = win.pageYOffset || isBoxModel && docElem.scrollTop || bodyElem.scrollTop\n  scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || bodyElem.scrollLeft\n\n  adjustedScrollTop = scrollTop - clientTop\n  adjustedScrollLeft = scrollLeft - clientLeft\n\n  offsetTop = boxElem.top + adjustedScrollTop\n  offsetLeft = boxElem.left + adjustedScrollLeft\n  offsetBottom = boxElem.bottom + adjustedScrollTop\n  offsetRight = boxElem.right + adjustedScrollLeft\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetBottom,\n    right: offsetRight\n  }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directive_input__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directive_inputPicker__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directive_picker__ = __webpack_require__(3);\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = __WEBPACK_IMPORTED_MODULE_0_angular___default.a\n  .module('$moment', [])\n  .provider('$moment', __WEBPACK_IMPORTED_MODULE_1__service__[\"a\" /* default */])\n  .filter('momentFormat', __WEBPACK_IMPORTED_MODULE_2__filter__[\"a\" /* default */])\n  .directive('input', __WEBPACK_IMPORTED_MODULE_3__directive_input__[\"a\" /* default */])\n  .directive('inputPicker', __WEBPACK_IMPORTED_MODULE_4__directive_inputPicker__[\"a\" /* default */])\n  .directive('momentPicker', __WEBPACK_IMPORTED_MODULE_5__directive_picker__[\"a\" /* default */])\n  .name;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// angular-moment.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c2f5f96a8870be363408","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 0\n// module chunks = 0","import angular from 'angular'\nimport indexOf from 'indexof'\n\nexport default ['$moment', '$timeout', function inputDirective ($moment, $timeout) {\n  // Maybe expose a setting for localization someday...\n  var stepUnits = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year']\n  var strictView = $moment.$strictView\n  var strictModel = $moment.$strictModel\n\n  return {\n    priority: 10,\n    restrict: 'E',\n    require: '?ngModel',\n    compile: function inputCompile (tElement, tAttr) {\n      // Support both input[type=date] and input[type=moment] so one can use type=moment if\n      // browser vendor type=date functionality is undesired (*ehem* Chrome).\n      if (tAttr.type !== 'date' && tAttr.type !== 'moment') { return angular.noop }\n      return function inputPostLink (scope, element, attr, ctrl) {\n        // All the functionality of this directive requires ngModelCtrl.\n        if (!ctrl) { return }\n\n        // A Moment of the last value passed through the directive's validator. Allows\n        // stepping function to not have to reparse ctrl.$viewValue and potentially fail\n        // if another directive's formatter has changed the view value format.\n        var momentValue\n            // Formats may be overridden if attr.(view|model)Format or attr.format is set.\n        var viewFormat = $moment.$defaultViewFormat\n        var modelFormat = $moment.$defaultModelFormat\n        var stepUnit, stepQuantity\n            // We track focus state to prevent stepping if elem is blurred.\n        var hasFocus = false\n            // Min/max must be reparsed using view/model formats to account for differences\n            // in date specificity. E.g., if min is '01-30-2000' and viewFormat is 'MM-YYYY'\n            // and the model value is '01-2000'.\n        var moments = {\n          min: {\n            attr: null,\n            view: null,\n            model: null\n          },\n          max: {\n            attr: null,\n            view: null,\n            model: null\n          }\n        }\n\n        // Utility Functions\n        // ///////////////////\n\n        var setPlaceholder = function (format) {\n          if (!element.attr('placeholder')) { element.attr('placeholder', $moment.$parseFormat(format)) }\n        }\n\n        var reparseOrReformatValue = function () {\n          var hasModelValue = !ctrl.$isEmpty(ctrl.$modelValue)\n          var hasViewValue = !ctrl.$isEmpty(ctrl.$viewValue)\n\n          if (hasModelValue) { reformatModelValue() } else if (hasViewValue) { reparseViewValue() }\n        }\n\n        var reparseViewValue = function () {\n          if (!ctrl.$isEmpty(ctrl.$viewValue)) { ctrl.$setViewValue(ctrl.$viewValue) }\n        }\n        var reformatModelValue = function () {\n          // Is there a better way to resend the model value through the formatter pipeline?\n          var modelValue = ctrl.$modelValue\n          if (!ctrl.$isEmpty(modelValue)) {\n            $timeout(function () {\n              scope.$apply(function () { scope[attr.ngModel] = modelValue + ' ' })\n              scope.$apply(function () { scope[attr.ngModel] = modelValue })\n            }, 0, false)\n          }\n        }\n\n        var setViewModelMomentsForAttr = function (attr) {\n          // attr is either 'min' or 'max'\n          if (moments[attr].attr && moments[attr].attr.isValid()) {\n            moments[attr].view = $moment(moments[attr].attr.format(viewFormat), viewFormat)\n            moments[attr].model = $moment(moments[attr].attr.format(modelFormat), modelFormat)\n          } else { moments[attr].attr = moments[attr].view = moments[attr].model = null }\n        }\n\n        // Date Validation and Formatting\n        // ////////////////////////////////\n\n        var parseValidateAndFormatDate = function parseValidateAndFormatDate (origin, value) {\n          var moment, isValid, isEmpty, inputFormat, outputFormat, strict\n\n          if (origin === 'view') {\n            inputFormat = viewFormat\n            outputFormat = modelFormat\n            strict = strictView\n          } else {\n            inputFormat = modelFormat\n            outputFormat = viewFormat\n            strict = strictModel\n          }\n\n          moment = $moment(value, inputFormat, strict)\n          isValid = moment.isValid()\n          isEmpty = ctrl.$isEmpty(value)\n          momentValue = isEmpty ? $moment(null) : moment.clone()\n\n          // Date validation\n          if (!isEmpty && !isValid) {\n            ctrl.$setValidity('date', false)\n            if (attr.min) ctrl.$setValidity('min', true)\n            if (attr.max) ctrl.$setValidity('max', true)\n            return undefined\n          } else { ctrl.$setValidity('date', true) }\n\n          // Min validation\n          if (attr.min) {\n            if (!isEmpty && isValid && moments.min.attr && moment.isBefore(moments.min[origin])) { ctrl.$setValidity('min', false) } else { ctrl.$setValidity('min', true) }\n          }\n\n          // Max validation\n          if (attr.max) {\n            if (!isEmpty && isValid && moments.max.attr && moment.isAfter(moments.max[origin])) { ctrl.$setValidity('max', false) } else { ctrl.$setValidity('max', true) }\n          }\n\n          // Output and formatting\n          if (ctrl.$error.min || ctrl.$error.max) { return undefined } else { return isEmpty ? value : moment.format(outputFormat) }\n        }\n\n        ctrl.$parsers.push(angular.bind(undefined, parseValidateAndFormatDate, 'view'))\n        ctrl.$formatters.push(angular.bind(undefined, parseValidateAndFormatDate, 'model'))\n\n        // Process format, viewFormat, modelFormat attrs\n        // ///////////////////////////////////////////////\n\n        if (attr.format && (!attr.viewFormat || !attr.modelFormat)) {\n          viewFormat = scope.$eval(attr.format) || viewFormat\n          modelFormat = scope.$eval(attr.format) || modelFormat\n\n          scope.$watch(attr.format, function formatWatchAction (value) {\n            viewFormat = value\n            modelFormat = value\n            setPlaceholder(value)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        if (attr.viewFormat) {\n          viewFormat = scope.$eval(attr.viewFormat) || viewFormat\n\n          scope.$watch(attr.viewFormat, function viewFormatWatchAction (format) {\n            format = format || $moment.$defaultViewFormat\n            if (format === viewFormat) return\n            viewFormat = format\n            setPlaceholder(format)\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reformatModelValue()\n          })\n        }\n\n        if (attr.modelFormat) {\n          modelFormat = scope.$eval(attr.modelFormat) || modelFormat\n\n          scope.$watch(attr.modelFormat, function modelFormatWatchAction (format) {\n            format = format || $moment.$defaultModelFormat\n            if (format === modelFormat) return\n            modelFormat = format\n            setViewModelMomentsForAttr('min')\n            setViewModelMomentsForAttr('max')\n            reparseViewValue()\n          })\n        }\n\n        setPlaceholder(viewFormat)\n\n        // Min/Max Validation\n        // ////////////////////\n\n        var minWatchAction = function minWatchAction (minAttr) {\n          var moment\n          if (angular.isArray(minAttr) && minAttr.length === 2) { moment = $moment(minAttr[0], minAttr[1]) } else if (minAttr && angular.isString(minAttr)) {\n            if (minAttr === 'today') { moment = $moment() } else { moment = $moment(minAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n          // Has the min changed?\n          if (!moment ^ !moments.min.attr || (moment && moments.min.attr && moment.format('X') !== moments.min.attr.format('X'))) {\n            moments.min.attr = moment\n            setViewModelMomentsForAttr('min')\n            reparseOrReformatValue()\n          }\n        }\n\n        minWatchAction(scope.$eval(attr.min))\n        scope.$watch(function () {\n          return scope.$eval(attr.min)\n        }, minWatchAction, true)\n\n        var maxWatchAction = function maxWatchAction (maxAttr) {\n          var moment\n          if (angular.isArray(maxAttr) && maxAttr.length === 2) { moment = $moment(maxAttr[0], maxAttr[1]) } else if (maxAttr && angular.isString(maxAttr)) {\n            if (maxAttr === 'today') { moment = $moment() } else { moment = $moment(maxAttr, $moment.$defaultModelFormat) }\n          } else { moment = null }\n\n          if (!moment ^ !moments.max.attr || (moment && moments.max.attr && moment.format('X') !== moments.max.attr.format('X'))) {\n            moments.max.attr = moment\n            setViewModelMomentsForAttr('max')\n            reparseOrReformatValue()\n          }\n        }\n\n        maxWatchAction(scope.$eval(attr.max))\n        scope.$watch(function () {\n          return scope.$eval(attr.max)\n        }, maxWatchAction, true)\n\n        // Stepping\n        // //////////\n\n        // TODO: Allow this to be config'ed\n        stepUnit = 'day'\n        stepQuantity = 1\n\n        if (attr.step) {\n          scope.$watch(attr.step, function stepWatchAction (step) {\n            if (!step || !angular.isString(step)) { return }\n\n            var match = step.match(/(\\d+)\\s(\\w+)/)\n            if (match) {\n              stepUnit = match[2]\n              stepQuantity = parseInt(match[1], 10)\n            } else {\n              stepUnit = 'day'\n              stepQuantity = 1\n            }\n          })\n        }\n\n        var inputStepHandler = function (event, eventData) {\n          // Allow for passing custom event object in tests (so Kosher)\n          // TODO: Use gulp-remove-lines to strip this from build\n          if (!event.type && eventData && eventData.type) {\n            angular.extend(event, eventData)\n            hasFocus = true\n          }\n\n          if (element.attr('readonly')) { return }\n\n          //                               Up|Dn\n          if (!hasFocus || (event.type === 'keydown' && !/38|40/.test(event.which))) return\n          event.preventDefault()\n\n          var isViewEmpty = ctrl.$isEmpty(ctrl.$viewValue)\n          var momentView = isViewEmpty ? $moment() : $moment(momentValue.format(viewFormat), viewFormat, true)\n          var wheelDelta, isIncrease, shiftedStepUnit, momentViewStepped, steppedViewValue\n\n          if (!momentView.isValid()) { return }\n\n          if (event.type === 'keydown') { isIncrease = /38/.test(event.which) } else {\n            wheelDelta = event.originalEvent ? event.originalEvent.wheelDelta : event.wheelDelta\n            isIncrease = wheelDelta / 120 > 0\n          }\n\n          if (event.shiftKey) {\n            shiftedStepUnit = stepUnits[(indexOf(stepUnits, stepUnit.replace(/s$/, '')) + 1)] || stepUnit\n          } else shiftedStepUnit = stepUnit\n\n          if (isViewEmpty && moments.min.attr) {\n            // Always step an empty value to the min if specified\n            momentViewStepped = moments.min.view.clone()\n          } else if (isIncrease) {\n            if (isViewEmpty && !moments.min.attr) {\n              // Then use today's date clamped to max\n              momentViewStepped = momentView.max(moments.max.attr ? moments.max.view : undefined)\n            } else if (moments.min.attr && momentView.isBefore(moments.min.view)) {\n              momentViewStepped = moments.min.view.clone()\n            } else if (moments.max.attr && !momentView.isAfter(moments.max.view)) {\n              // Then step value up, clamp to max\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity).max(moments.max.view)\n            } else if (!moments.max.attr) {\n              // If there's no max, increase; otherwise leave it exceeding max--we'll only bring it\n              // back in bounds of the max when user decreases value.\n              // This mimic's browser vendor behavior with min/max stepping for input[type=number]\n              momentViewStepped = momentView.add(shiftedStepUnit, stepQuantity)\n            }\n          } else {\n            // The opposite for decrease\n            if (isViewEmpty && !moments.max.attr) {\n              momentViewStepped = momentView.min(moments.min.attr ? moments.min.view : undefined)\n            } else if (moments.max.attr && momentView.isAfter(moments.max.view)) {\n              momentViewStepped = moments.max.view.clone()\n            } else if (moments.min.attr && !momentView.isBefore(moments.min.view)) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity).min(moments.min.view)\n            } else if (!moments.min.attr) {\n              momentViewStepped = momentView.subtract(shiftedStepUnit, stepQuantity)\n            }\n          }\n\n          steppedViewValue = (momentViewStepped || momentView).format(viewFormat)\n\n          scope.$apply(function () {\n            ctrl.$setViewValue(steppedViewValue)\n            ctrl.$render()\n          })\n        }\n\n        element.on('mousewheel keydown', inputStepHandler)\n\n        element.on('focus', function (e) { hasFocus = true })\n        element.on('blur', function (e) { hasFocus = false })\n      }\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_input.js\n// module id = 1\n// module chunks = 0","import angular from 'angular'\n\nexport default ['$moment', '$log', function inputDirective ($moment, $log) {\n  var weekStartDay = $moment().startOf('week').format('d')\n  // var weekEndDay = $moment().endOf('week').format('d')\n  var getTemplateDefinition = function (templateName) {\n    return $moment.$$pickerTemplates[templateName || 'default']\n  }\n\n  return {\n    restrict: 'A',\n    templateUrl: function (tElement, tAttrs) {\n      var template = getTemplateDefinition(tAttrs.template)\n      if (template) { return template.url }\n      // Ya dun' goofed.\n      $log.error('Error: [momentDatepicker] Picker template \\'' + tAttrs.template + '\\' is undefined. Templates must be defined with \\'$momentProvider.definePickerTemplate\\'.')\n    },\n    scope: {\n      dateModel: '=momentPicker',\n      format: '=?',\n      modelFormat: '=?',\n      min: '=?',\n      max: '=?',\n      ngShow: '=?'\n    },\n    controller: ['$scope', '$element', '$attrs', '$parse', '$animate', '$moment',\n      function ($scope, $element, $attr, $parse, $animate, $moment) {\n        var self = this\n\n        self.template = getTemplateDefinition($attr.template)\n        self.format = $moment.$defaultModelFormat\n\n        self.pickedMoment = Number.NaN\n        self.maxMoment = Number.NaN\n        self.minMoment = Number.NaN\n\n        self.visible = true\n        self.hidden = false\n\n        function init () {\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          self.setDisplayMoment($moment())\n          rebuildScopeMoments()\n\n          $scope.weekMoments = []\n          var i = 7\n          while (i--) { $scope.weekMoments.unshift($moment().startOf('week').add(i, 'day')) }\n        }\n\n        // Ctrl Methods\n        // //////////////\n\n        self.setVisibility = function (isVisible) {\n          self.hidden = !isVisible\n          self.visible = !!isVisible\n          $animate[!isVisible ? 'addClass' : 'removeClass']($element, 'ng-hide')\n        }\n\n        self.setPickedMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          if (!isValid) {\n            self.pickedMoment = null\n            $scope.pickedMoment = null\n            return\n          }\n\n          if (self.minMoment && moment.isBefore(self.minMoment, self.template.unit)) { return }\n          if (self.maxMoment && moment.isAfter(self.maxMoment, self.template.unit)) { return }\n\n          // Clamp it to the min/max to keep it valid\n          if (self.minMoment) { moment = moment.min(self.minMoment) }\n          if (self.maxMoment) { moment = moment.max(self.maxMoment) }\n\n          if (moment.isSame(self.pickedMoment)) { return }\n\n          self.pickedMoment = moment.clone()\n          $scope.pickedMoment = moment.clone()\n          $scope.dateModel = moment.format(self.format)\n\n          self.setDisplayMoment(moment)\n        }\n\n        self.setDisplayMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n          var fallbackMoment = self.pickedMoment ? self.pickedMoment : $moment()\n\n          self.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n          $scope.displayMoment = isValid ? moment.clone() : fallbackMoment.clone()\n\n          rebuildScopeMoments()\n        }\n\n        self.setMinMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.minMoment = isValid ? moment.clone() : null\n        }\n\n        self.setMaxMoment = function (input, format, lang, strict) {\n          var moment = $moment.apply(null, arguments)\n          var isValid = input && moment.isValid()\n\n          self.maxMoment = isValid ? moment.clone() : null\n        }\n\n        self.setFormat = function (format) {\n          if (angular.equals(self.format, format)) { return }\n\n          self.format = format || $moment.$defaultModelFormat\n          self.setPickedMoment($scope.dateModel, self.format, $moment.$strictModel)\n        }\n\n        // Watchers\n        // /////////\n\n        $scope.$watch('dateModel', function (modelValue) {\n          self.setPickedMoment(modelValue, self.format, $moment.$strictModel)\n        })\n\n        // Format or modelFormat\n        if ($attr.format && !$attr.modelFormat) {\n          self.format = $scope.format || $moment.$defaultModelFormat\n          $scope.$watch('format', self.setFormat)\n        } else if ($attr.modelFormat) {\n          self.format = $scope.modelFormat || $moment.$defaultModelFormat\n          $scope.$watch('modelFormat', self.setFormat)\n        }\n\n        // Min, Max\n        if ($attr.min) {\n          $scope.$watch('min', function (minValue) {\n            var isArray = angular.isArray(minValue)\n            self.setMinMoment.apply(null, isArray ? minValue : [minValue])\n          }, true)\n        }\n\n        if ($attr.max) {\n          $scope.$watch('max', function (maxValue) {\n            var isArray = angular.isArray(maxValue)\n            self.setMaxMoment.apply(null, isArray ? maxValue : [maxValue])\n          }, true)\n        }\n\n        // Add ctrl methods to the scope that are\n        // suitable for use in the picker template.\n        // /////////////////////////////////////////\n\n        $scope.setPickerVisibility = self.setVisibility\n        $scope.setDisplayMoment = self.setDisplayMoment\n        $scope.setPickedMoment = self.setPickedMoment\n\n        // Private methods\n\n        function rebuildScopeMoments () {\n          var lastMonthMoment = self.displayMoment.clone().startOf('month')\n          var thisMonthMoment = lastMonthMoment.clone()\n          var nextMonthMoment = self.displayMoment.clone().endOf('month')\n          var thisMonth = self.displayMoment.format('M')\n          var thisYear = self.displayMoment.format('YYYY')\n\n          if ($scope.thisMonthMoments.length && thisMonthMoment.isSame($scope.thisMonthMoments[0])) { return }\n\n          $scope.today = $moment()\n          $scope.lastMonthMoments = []\n          $scope.thisMonthMoments = []\n          $scope.nextMonthMoments = []\n          $scope.monthsThisYearMoments = []\n\n          while (lastMonthMoment.format('d') !== weekStartDay) { $scope.lastMonthMoments.unshift(lastMonthMoment.subtract(1, 'day').clone()) }\n\n          while (thisMonthMoment.format('M') === thisMonth) {\n            $scope.thisMonthMoments.push(thisMonthMoment.clone())\n            thisMonthMoment.add(1, 'day')\n          }\n\n          while ($scope.lastMonthMoments.length + $scope.thisMonthMoments.length + $scope.nextMonthMoments.length < 42) { $scope.nextMonthMoments.push(nextMonthMoment.add(1, 'day').clone()) }\n\n          while ($scope.monthsThisYearMoments.length < 12) {\n            $scope.monthsThisYearMoments.push(\n              $moment({ year: thisYear, month: $scope.monthsThisYearMoments.length })\n            )\n          }\n        }\n\n        init()\n      }\n    ],\n    require: 'momentPicker',\n    link: function (scope, element, attr, ctrl) {\n      // View helpers\n      // //////////////\n\n      scope.getClasses = function (moment, classes) {\n        var isWeekend = /6|7/.test(moment.isoWeekday())\n        var isWeekday = !isWeekend\n        var classObject = {\n          weekend: isWeekend,\n          weekday: isWeekday\n        }\n\n        // Convenience classes: jan fri\n        classObject[ moment.format('MMM ddd').toLowerCase() ] = true\n\n        if (!classes) { return classObject }\n\n        // Iterate over requested class names\n        angular.forEach(classes.split(' '), function (className) {\n          var name = className.split('-')[0]\n          var unit = className.split('-')[1] || ctrl.template.unit\n\n          if (scope.pickedMoment && name === 'picked') { classObject[className] = moment.isSame(scope.pickedMoment, ctrl.template.unit) } else if (name === 'current') { classObject[className + ' current'] = moment.isSame(scope.today, unit) } else if (name === 'invalid' && (ctrl.minMoment || ctrl.maxMoment)) {\n            if (ctrl.minMoment && moment.isBefore(ctrl.minMoment, unit)) { classObject[className + ' invalid'] = true } else if (ctrl.maxMoment && moment.isAfter(ctrl.maxMoment, unit)) { classObject[className + ' invalid'] = true }\n          }\n        })\n\n        return classObject\n      }\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_inputPicker.js\n// module id = 2\n// module chunks = 0","// Picker extends moment input directive with positioned momentPicker\n\nimport angular from 'angular'\nimport { getOffset } from './utils'\n\nexport default ['$moment', '$compile', function inputDirective ($moment, $compile) {\n  var defaultStyleAttr = 'style=\"position:absolute\" class=\"input-picker\"'\n  var copiedAttrs = 'format modelFormat min max'.split(' ')\n\n  var toSpinalCase = function (string) {\n    return string.replace(/[a-z][A-Z]/g, function (w) { return w[0] + '-' + w[1] }).toLowerCase()\n  }\n\n  return {\n    restrict: 'A',\n    require: ['?ngModel'],\n    link: function (scope, element, attr, ctrl) {\n      if (!ctrl || attr.type !== 'moment') { return }\n\n      var pickerAttrs = [ defaultStyleAttr ]\n      var pickerElem, pickerScope, pickerCtrl, deregisterWatch\n\n      function init () {\n        deregisterWatch()\n        pickerScope = pickerElem.isolateScope()\n        pickerCtrl = pickerElem.controller('momentPicker')\n        pickerCtrl.setVisibility(false)\n        pickerScope.showClose = true\n      }\n\n      // Copy relevent attrs from input to picker\n      if (attr.picker) { pickerAttrs.push('template=' + attr.picker) }\n\n      angular.forEach(copiedAttrs, function (name) {\n        if (attr[name]) { pickerAttrs.push(toSpinalCase(name) + '=\"' + attr[name] + '\"') }\n      })\n\n      // Compile/inject/bind events to picker\n      pickerElem = $compile('<div moment-picker=\"' + attr.ngModel + '\" ' + pickerAttrs.join(' ') + '></div>')(scope)\n\n      // Watch for controller instantiation\n      deregisterWatch = scope.$watch(function () {\n        if (pickerElem.controller('momentPicker')) { init() }\n      })\n\n      // DOM manipulation and event watching\n      angular.element(document.body).append(pickerElem)\n\n      pickerElem.on('mousedown', function (event) {\n        event.preventDefault()\n      })\n\n      // Input event binding\n      element.on('focus click', function (event) {\n        var offset = getOffset(element[0])\n\n        pickerElem.css({\n          left: offset.left + 'px',\n          top: offset.bottom + 'px'\n        })\n\n        pickerCtrl.setVisibility(true)\n      })\n\n      element.on('blur keydown', function (event) {\n        if (event.type === 'keydown' && event.which !== 27) { return }\n        pickerCtrl.setVisibility(false)\n      })\n\n      // Destruction cleanup\n      scope.$on('$destroy', function () {\n        pickerElem.off().remove()\n      })\n    }\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/directive_picker.js\n// module id = 3\n// module chunks = 0","import angular from 'angular'\n\nexport default ['$moment', function ($moment) {\n  // Format: String or Array\n  // String: Moment output format (defaults to defaultViewFormat)\n  // Array: Moment input format, moment output format, [strict]\n  return function momentFormatFilter (date, format) {\n    var moment, strict, inputFormat,\n      outputFormat = $moment.$defaultViewFormat\n\n    if (!angular.isDefined(date)) { return date }\n\n    if (angular.isString(format)) { outputFormat = format } else if (angular.isArray(format)) {\n      inputFormat = format[0]\n      outputFormat = format[1] || outputFormat\n      strict = format[2]\n    }\n\n    moment = $moment(date, inputFormat, strict)\n\n    if (moment.isValid()) { return moment.format(outputFormat) }\n\n    // Try parsing it with the defaultModelFormat if inputFormat wasn't specified\n    if (!angular.isDefined(inputFormat)) {\n      moment = $moment(date, $moment.$defaultModelFormat, $moment.strictModel)\n      if (moment.isValid()) { return moment.format(outputFormat) }\n    }\n\n    return date\n  }\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/filter.js\n// module id = 4\n// module chunks = 0","import angular from 'angular'\nimport moment from 'moment'\n\nexport default function $momentProvider () {\n  // Strict parsing has trouble in Moment.js v2.32.5 with short tokens\n  // E.g. 1-31-2000, M-D-YYYY is invalid.\n  var config = {\n    $$pickerTemplates: {},\n    $strictView: true,\n    $strictModel: true,\n    $defaultViewFormat: 'L',\n    $defaultModelFormat: moment.defaultFormat,\n    $parseFormat: $parseFormat\n  }\n\n  // For parsing locale-dependent date formats (L, LL, etc.)\n  function $parseFormat (format) {\n    format = format || ''\n    if (format.match(/l/i)) { return moment().lang()._longDateFormat[format] || format }\n    return format\n  }\n\n  this.defaultViewFormat = function (format) {\n    if (angular.isString(format)) { config.$defaultViewFormat = format }\n    return this\n  }\n\n  this.defaultModelFormat = function (format) {\n    if (angular.isString(format)) { config.$defaultModelFormat = format }\n    return this\n  }\n\n  this.strictView = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictView = bool }\n    return this\n  }\n\n  this.strictModel = function (bool) {\n    if (typeof bool === 'boolean') { config.$strictModel = bool }\n    return this\n  }\n\n  this.definePickerTemplate = function (template) {\n    if (angular.isObject(template) && template.name && template.url) {\n      config.$$pickerTemplates[template.name] = {\n        url: template.url,\n        unit: template.unit || 'days'\n      }\n    }\n    return this\n  }\n\n  this.$get = function () {\n    if (angular.isDefined(moment.$strictView)) { return moment }\n    try {\n      Object.defineProperty(moment, '$strictView', {\n        value: config.$strictView\n      })\n      Object.defineProperty(moment, '$strictModel', {\n        value: config.$strictModel\n      })\n      Object.defineProperty(moment, '$defaultViewFormat', {\n        value: config.$defaultViewFormat\n      })\n      Object.defineProperty(moment, '$defaultModelFormat', {\n        value: config.$defaultModelFormat\n      })\n      Object.defineProperty(moment, '$parseFormat', {\n        value: config.$parseFormat\n      })\n      Object.defineProperty(moment, '$$pickerTemplates', {\n        value: angular.copy(config.$$pickerTemplates),\n        writable: true\n      })\n    } catch (err) { angular.extend(moment, config) }\n    return moment\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/service.js\n// module id = 5\n// module chunks = 0","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/indexof/index.js\n// module id = 6\n// module chunks = 0","export {getOffset}\n\nfunction getOffset (elem) {\n  // Based on http://stackoverflow.com/a/8111175\n  if (!elem) { return }\n\n  var doc = document\n  var win = window\n  var bodyElem = doc.body\n  var docElem = doc.documentElement\n  var boxElem = doc.createElement('div')\n  var isBoxModel,\n    clientTop, clientLeft,\n    scrollTop, scrollLeft,\n    offsetTop, offsetRight, offsetBottom, offsetLeft,\n    adjustedScrollTop,\n    adjustedScrollLeft\n\n  boxElem.style.paddingLeft =\n  boxElem.style.width = '1px'\n\n  bodyElem.appendChild(boxElem)\n  isBoxModel = boxElem.offsetWidth == 2\n  bodyElem.removeChild(boxElem)\n  boxElem = elem.getBoundingClientRect()\n\n  clientTop = docElem.clientTop || bodyElem.clientTop || 0\n  clientLeft = docElem.clientLeft || bodyElem.clientLeft || 0\n  scrollTop = win.pageYOffset || isBoxModel && docElem.scrollTop || bodyElem.scrollTop\n  scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || bodyElem.scrollLeft\n\n  adjustedScrollTop = scrollTop - clientTop\n  adjustedScrollLeft = scrollLeft - clientLeft\n\n  offsetTop = boxElem.top + adjustedScrollTop\n  offsetLeft = boxElem.left + adjustedScrollLeft\n  offsetBottom = boxElem.bottom + adjustedScrollTop\n  offsetRight = boxElem.right + adjustedScrollLeft\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetBottom,\n    right: offsetRight\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 8\n// module chunks = 0","import angular from 'angular'\n\nimport service from './service'\nimport filter from './filter'\nimport inputDirective from './directive_input'\nimport inputPickerDirective from './directive_inputPicker'\nimport pickerDirective from './directive_picker'\n\nexport default angular\n  .module('$moment', [])\n  .provider('$moment', service)\n  .filter('momentFormat', filter)\n  .directive('input', inputDirective)\n  .directive('inputPicker', inputPickerDirective)\n  .directive('momentPicker', pickerDirective)\n  .name\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}